#include "HLSLSupport.cginc"
#include "UnityRaytracingMeshUtils.cginc"
#include "UnityShaderVariables.cginc"
#include "../../RayTraceHelpersUnigma.hlsl"
#include "UnityCG.cginc"


RWTexture2D<float4> _UnigmaGlobalIllumination;

RWStructuredBuffer<UnigmaLight> _unigmaLights;
RWStructuredBuffer<Sample> _samples;
RWStructuredBuffer<Reservoir> _reservoirs;

int _UnigmaFrameCount;
int _NumberOfLights;
int _TemporalReservoirsCount;

RaytracingAccelerationStructure _RaytracingAccelerationStructure;
#pragma max_recursion_depth 1

void InitializeRay(inout float3 orig, inout float3 dir)
{

}

void InitializeReservoir(inout Reservoir reservoir)
{
    reservoir.W = 0;
    reservoir.Y = 0;
    reservoir.pHat = 0;
    reservoir.M = 0;
    reservoir.wSum = 0;
}

bool addReservoirSample(inout Reservoir reservoir, uint lightX, float weight, float c, float2 randSeed)
{
    reservoir.M += c;
    reservoir.wSum += weight;

    if(rand(randSeed) < weight / reservoir.wSum)
    {
        reservoir.Y = lightX;
        return true;
    }

    return false;
}

float3 ComputeBRDF(inout Payload payload, in RayDesc ray, int bounce)
{
    float3 BRDF = 0;
    float bounceStrength = (1.0 / ((float)2*bounce+1.0f));

    float3 emittance = payload.color.xyz * payload.color.w *bounceStrength*0.1;

    float cos_theta = sdot(payload.direction, payload.normal);

    //BRDF(x) * Le(x) * G(x);
    BRDF = emittance * cos_theta*payload.color.xyz;// * (1.0/RUNITY_PI) / (1.0/(2*RUNITY_PI));
   
    return BRDF;
}

float4 areaSampleLights(inout Payload payload, inout RayDesc ray, inout Reservoir reservoir)
{
    //Initialize the payload and bounces.
    payload.color = float4(1,1,1,0);
    payload.distance = 99999;
    payload.direction = ray.Direction;
    payload.pixel += _Time.xy;

    
    float3 cachedPos = 0;
    float4 cachedColor = payload.color;

    float3 lightPosition = _unigmaLights[reservoir.Y].position;
    float3 BRDF = 0;

    //V(x1 <-> x2). Changing the distance from the hit point leads to interesting results.
    TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_NONE, 0xFF, 0, 1, 0, ray, payload);
    BRDF = ComputeBRDF(payload, ray, 0);

    ray.Direction = normalize(lightPosition - ray.Origin);
    TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_NONE, 0xFF, 0, 1, 0, ray, payload);
    BRDF *= step(0.001, payload.color.w);

    return float4(BRDF, 1.0);
}

float4 ShadePixel(inout Payload payload, inout RayDesc ray)
{
    float lightStrengthCostant = 0.1;
    payload.pixel += _Time.xy;
    //Hit the first object.
    TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_NONE, 0xFF, 0, 1, 0, ray, payload);
    float distanceFromPoint = 0.01;
    float3 materialColor = payload.color;
    float3 materialNormal = payload.direction;

    ray.Origin = ray.Origin + ray.Direction * (payload.distance - distanceFromPoint);
    ray.Direction = payload.direction;

    float3 materialPosition = ray.Origin;

    float3 BRDF = ComputeBRDF(payload, ray, 0);

    Reservoir temporalReservoir;
    InitializeReservoir(temporalReservoir);

    uint3 id = DispatchRaysIndex();
    uint3 dim = DispatchRaysDimensions();

    float4 pixelColor = 0;
    float pdf = 1.0 / (float)_NumberOfLights;
    float pHat = 0;

    float3 cachedPosition = ray.Origin;
    float3 cachedDirection = ray.Direction;


    //Algorithm 3, initial candidates
    for(uint i = 0; i < _NumberOfLights; i++)
    {
        float2 randSeed = payload.pixel + _Time.xy + float2(i, i*i+i);
        uint lightIndex = uint(rand(randSeed) * (_NumberOfLights));

        float3 lightPosition = _unigmaLights[lightIndex].position;

        float3 toLight = normalize(lightPosition - ray.Origin);
        
        float cosTheta = sdot(payload.direction, toLight);
        pHat = length(payload.color.xyz / RUNITY_PI *  (_unigmaLights[lightIndex].emission*lightStrengthCostant)*cosTheta);
       
        float weight = pHat;// / pdf;
        addReservoirSample(temporalReservoir, lightIndex, weight, 1, randSeed);
    }




    
    //Evaluate visibility for initial candidates
    uint lightIndex = temporalReservoir.Y;

    float3 lightPosition = _unigmaLights[lightIndex].position;

    float3 toLight = normalize(lightPosition - materialPosition);
        
    float cosTheta = sdot(payload.direction, toLight);



    
    ray.Direction = toLight;
    ray.Origin = materialPosition;
    TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_NONE, 0xFF, 0, 1, 0, ray, payload);
    float visible = step(0.0001, payload.color.w);

    if(visible < 0.001)
    {
        temporalReservoir.W = 0;
    }

 
    //Temporal reuse.
    //Add current sample.
    float2 randSeedR2 = payload.pixel + _Time.xy + float2(rand(payload.pixel + id.xy), rand(payload.pixel + dim.xy));
    float weightR2 =  pHat * temporalReservoir.W * temporalReservoir.M;
    
    pHat = length(payload.color.xyz / RUNITY_PI *  (_unigmaLights[lightIndex].emission*lightStrengthCostant)*cosTheta);

    temporalReservoir.W = pHat > 0.0 ? (temporalReservoir.wSum / temporalReservoir.M) / pHat : 0.0;
    addReservoirSample(temporalReservoir, temporalReservoir.Y, weightR2, 0, randSeedR2);
    
    //Add previous samples.
    for(int i = 0; i < _TemporalReservoirsCount; i++)
    {
        int currentIndex =  id.x + id.y*dim.x + i*dim.x*dim.y;

        Reservoir previousReservoir = _reservoirs[currentIndex];
        previousReservoir.M = min(15 * temporalReservoir.M, previousReservoir.M);

        lightIndex = previousReservoir.Y;

        lightPosition = _unigmaLights[lightIndex].position;

        toLight = normalize(lightPosition - materialPosition);
        
        cosTheta = sdot(materialNormal, toLight);

        pHat = length(materialColor / RUNITY_PI *  (_unigmaLights[lightIndex].emission*lightStrengthCostant)*cosTheta);

        float randSeedR = payload.pixel + _Time.xy + float2(i, i*i*i);
        float weightR =  pHat * previousReservoir.W * previousReservoir.M;
        addReservoirSample(temporalReservoir, previousReservoir.Y, weightR, previousReservoir.M, randSeedR);
    }
    

    lightIndex = temporalReservoir.Y;

    lightPosition = _unigmaLights[lightIndex].position;

    toLight = normalize(lightPosition - materialPosition);
        
    cosTheta = sdot(materialNormal, toLight);

    pHat = length(materialColor / RUNITY_PI *  (_unigmaLights[lightIndex].emission*lightStrengthCostant)*cosTheta);
    temporalReservoir.W = pHat > 0.0 ? (temporalReservoir.wSum / temporalReservoir.M) / pHat : 0.0;

    int currentReservoirTemporal = _UnigmaFrameCount % _TemporalReservoirsCount;
    int reservoirIndex = id.x + id.y*dim.x + currentReservoirTemporal*dim.x*dim.y;
    _reservoirs[reservoirIndex] = temporalReservoir;

    //Spatial reuse
    int _NumberOfNeighbors = 15;
    int _NeighborsRadius = 5;

    for(int i = 0; i < _NumberOfNeighbors; i++)
    {
        float2 neighborIndex = 0;
        float2 randSeed = payload.pixel + _Time.xy + float2(i, i*i*i);
        neighborIndex.x = int(rand(randSeed) * _NeighborsRadius * 2.f) - _NeighborsRadius;
		neighborIndex.y = int(rand(randSeed+1) * _NeighborsRadius * 2.f) - _NeighborsRadius;

		neighborIndex.x = max(0, min(dim.x - 1, id.x + neighborIndex.x));
		neighborIndex.y = max(0, min(dim.y - 1, id.y + neighborIndex.y));

        int currentReservoirTemporal = _UnigmaFrameCount % _TemporalReservoirsCount;
        int reservoirIndex = neighborIndex.x + neighborIndex.y*dim.x + currentReservoirTemporal*dim.x*dim.y;

        Reservoir neighborReservoir = _reservoirs[reservoirIndex];

        lightIndex = neighborReservoir.Y;

        lightPosition = _unigmaLights[lightIndex].position;

        toLight = normalize(lightPosition - materialPosition);
        
        cosTheta = sdot(materialNormal, toLight);

        pHat = length(materialColor / RUNITY_PI *  (_unigmaLights[lightIndex].emission*lightStrengthCostant)*cosTheta);
        float weightR =  pHat * neighborReservoir.W * neighborReservoir.M;
        addReservoirSample(temporalReservoir, neighborReservoir.Y, weightR, neighborReservoir.M, randSeed);
    }


    //pixelColor = areaSampleLights(payload, ray, temporalReservoir) + float4(BRDF, 1);
    lightIndex = temporalReservoir.Y;

    lightPosition = _unigmaLights[lightIndex].position;

    toLight = normalize(lightPosition - materialPosition);
        
    cosTheta = sdot(materialNormal, toLight);

    pHat = length(materialColor / RUNITY_PI *  (_unigmaLights[lightIndex].emission*lightStrengthCostant)*cosTheta);
    temporalReservoir.W = pHat > 0.0 ? (temporalReservoir.wSum / temporalReservoir.M) / pHat : 0.0;
    temporalReservoir.pHat = pHat;
    

    float4 weightFinal = temporalReservoir.W;

    //Set this reservoir as a past frame.


    
    return weightFinal*pHat + float4(BRDF, 1);

}

[shader("raygeneration")]
void RestirGlobalIllumantionRayGen()
{
    uint2 dispatchIdx = DispatchRaysIndex().xy;
   
    uint3 id = DispatchRaysIndex();
    uint3 dim = DispatchRaysDimensions();

    //Convert to 0 - 1.
    float2 pixel = ((id.xy + float2(0.5, 0.5)) / float2(dim.x, dim.y)) * 2 - 1;
    
    float3 chosenCameraPosition;
    float3 chosenDirection;

    float frameCount = 100;
    if(_UnigmaFrameCount > (int)frameCount)
        return;
    //Is it orthographic?
    if (unity_OrthoParams.w > 0)
    {
        //Camera is orthographic.
        //Convert to camera space.
        float4 viewPos = mul(unity_CameraInvProjection, float4(pixel.x, pixel.y, -1, 1));
        //Perspective divide.
        viewPos /= viewPos.w;
    
        //Convert to world space.
        float3 worldPosPixel = mul(unity_MatrixInvV, viewPos).xyz;
        float3 worldSpaceViewForward = -UNITY_MATRIX_I_V._m02_m12_m22;
        
        chosenCameraPosition = worldPosPixel; //No need to get direction from camera's origin.
        chosenDirection = normalize(worldSpaceViewForward);

    }
    else
    {
        //Camera is Perspective.
        //Convert to camera space.
        float4 viewPos = mul(unity_CameraInvProjection, float4(pixel.x, pixel.y, 1, 1));
        //Perspective divide.
        viewPos /= viewPos.w; //This takes into account field of view, how the frustrum of the view plane is.
    
        //Convert to world space.
        float3 worldPosPixel = mul(unity_MatrixInvV, viewPos).xyz;

        //Take the pixel and get the direction from the origin to create perspective.
        float3 worldDirection = normalize(worldPosPixel - _WorldSpaceCameraPos);
        float3 worldSpaceViewForward = -UNITY_MATRIX_I_V._m02_m12_m22;

        chosenCameraPosition = _WorldSpaceCameraPos;
        chosenDirection = worldDirection;
    }

    float3 position;


    //Creating RayDesc.
    RayDesc ray;
    ray.Origin = chosenCameraPosition; 
    ray.Direction = chosenDirection; 
    ray.TMin = 0;
    ray.TMax = 10000;

    Payload payload;
    payload.color = float4(1,1,1,0);
    payload.distance = 99999;
    payload.direction = chosenDirection;
    payload.pixel = pixel;

    int currentReservoirTemporal = _UnigmaFrameCount % _TemporalReservoirsCount;
    int reservoirIndex = id.x + id.y*dim.x + currentReservoirTemporal*dim.x*dim.y;
    /*
    _reservoirs[reservoirIndex].Y = 0;
    _reservoirs[reservoirIndex].M = 0;
    _reservoirs[reservoirIndex].wSum = 0;
    _reservoirs[reservoirIndex].W = 0;
    _reservoirs[reservoirIndex].pHat = 0;



    //Samples Amount
    int samples = 30;
    int maxBounces = 8;

    float3 radiance = 0;
    float3 emittance = 0;
    float3 BRDF = 0;
    float hitObject = 0;
    float3 directionCache = chosenDirection;
    for(int i = 0; i < samples; i++)
    { 
        emittance = 0;
        BRDF = 0;
        ray.Origin = chosenCameraPosition; 
        ray.Direction = chosenDirection;
        payload.color = float4(1,1,1,0);
        payload.distance = 99999;
        payload.direction = chosenDirection;
        for(int j = 0; j < maxBounces; j++)
        {
            payload.pixel = float2(i, j) + _Time.xy + pixel;
            float bounceStrength = (1.0 / ((float)2*j+1.0f));
            TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_NONE, 0xFF, 0, 1, 0, ray, payload);

            float3 rayDirection = payload.direction;
            //If it hit a point, divide by the amount of samples to get full energy.

            //float3 diffuse = RandomPointOnHemisphere(pixel, payload.direction,float2(i, j) + _Time.xy+pixel);
            //float3 specular = reflect(ray.d, hit.normal);

            if(payload.distance > 9999)
            {
                float3 toLightDir = normalize(_WorldSpaceLightPos0);
                float cos_theta_light = sdot(toLightDir, directionCache) + 0.25;
                emittance += float3(1,1,1)*2.75*bounceStrength;

                BRDF += float3(0.95,0.98,1)*bounceStrength*0.57; // sky.
                break;
            }
            hitObject = 1.0f;

            float cos_theta = sdot(rayDirection, payload.normal);
            BRDF += cos_theta*payload.color.xyz*bounceStrength;
            emittance += payload.color.xyz * payload.color.w *bounceStrength*0.0001*0.08;

             
            ray.Origin = ray.Origin + ray.Direction * (payload.distance - 0.0001);
            ray.Direction = rayDirection;

            directionCache = rayDirection;
        }
        radiance += (BRDF*(emittance))/(samples);
    }
    */
    /*
    TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_NONE, 0xFF, 0, 1, 0, ray, payload);


    //Remove.
    //_UnigmaGlobalIllumination[dispatchIdx] = payload.color;

    position = ray.Origin + ray.Direction * (payload.distance - 0.0001);
    //specular.
    ray.Origin = position;
    ray.Direction = payload.direction;
    TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_NONE, 0xFF, 0, 1, 0, ray, payload);
    */
    
    
    /*
    frameCount = 100;

    _UnigmaGlobalIllumination[dispatchIdx] = 0;
    for(int i = 0; i < frameCount; i++)
    {
        float inverseFrameSamples = 1.0f / frameCount;
        _UnigmaGlobalIllumination[dispatchIdx] += ShadePixel(payload, ray, _reservoirs[id.x + id.y*dim.x])*inverseFrameSamples;
    }
    */
    float inverseFrameSamples = 1.0f / frameCount;
    _UnigmaGlobalIllumination[dispatchIdx] += ShadePixel(payload, ray)*inverseFrameSamples;
    //_UnigmaGlobalIllumination[dispatchIdx] *= step(0.001, (_UnigmaFrameCount%frameCount)-1);
    
    //_UnigmaGlobalIllumination[dispatchIdx] += float4(radiance, hitObject)*inverseFrameSamples;//payload.color;

    //Add direct shadows.

}

[shader("miss")]
void MyMissShader(inout Payload payload : SV_RayPayload)
{
    payload.color = float4(1,1,1,0);
    payload.direction = 0;
    payload.distance = 99999;
    payload.pixel = -1;
    payload.normal = 0;
    
}