#pragma kernel CreateGrid
#pragma kernel UpdateParticles
#pragma kernel ComputeDensity
#pragma kernel ComputeForces
#pragma kernel UpdatePositionDeltas
#pragma kernel UpdatePositions
#pragma kernel HashParticles
#pragma kernel BitonicSort
#pragma kernel CalculateCellOffsets
#pragma kernel CalculateCurl
#pragma kernel CalculateVorticity
#pragma kernel PrefixSum
#pragma kernel CreateBVHTree
#pragma kernel CreateBoundingBox
#pragma kernel RadixSort
#pragma kernel AssignMortonCodes
#pragma kernel AssignParents
#pragma kernel AssignIndex

#include "../../ShaderHelpers.hlsl"
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 _ParentTransform;
float4x4 _CameraWorldToLocal;
float4x4 _ParentTransformToLocal;

float epsilon = 0.00001;
float _SizeOfParticle;
float _Smoothness;
float4 _DepthScale = 1;
float3 _LightSource;
float3 _LightScale;
float3 worldSpaceViewForward;
bool _IsOrthographic;
float _Radius = 1;
float _GasConstant;
float _BoundsDamping;
float _Viscosity;
float _RestDensity;
float _TimeStep = 2;
float _BoundDamping = 0.2;
float3 _BoxSize;
int _NumOfNodes;
int _FrustrumSize = 10;
uint _NumOfParticles;
uint _MaxNumOfParticles;
const uint MaxNeighbors = 50;
int biBlock;
int biDim;
int _ChosenParticle = 128;



struct MeshObject
{
    float4x4 localToWorld;
    int indicesOffset;
    int indicesCount;
    float3 position;
    float3 AABBMin;
    float3 AABBMax;
    float3 color;
    float emission;
    float smoothness;
    float transparency;
    float absorbtion;
    float celShaded;
    uint id;
};

struct Vertex
{
    float3 position;
    float3 normal;
    float2 uv;
};

struct Ray
{
    float3 o;
    float3 d;
    float3 color;
    float3 energy;
    int bounces;
};

struct Hit
{
    float3 position;
    float distance;
    float3 normal;
    float3 color;
    float2 uv;
    float depth;
    Vertex vertices[3];
    MeshObject meshObj;
};

struct Particle
{
    float4 force;
    float3 position;
    float3 lastPosition;
    float3 predictedPosition;
    float3 positionDelta;
    float3 debugVector;
    float3 velocity;
    float3 normal;
    float3 curl;
    float density;
    float lambda;
    float mass;
    int parent;
};

struct BVHNode
{
    float3 aabbMin;
    float3 aabbMax;
    int leftChild;
    int rightChild;
    int3 topChild;
    int3 bottomChild;
    int parent;
    int primitiveOffset;
    int primitiveCount;
    int index;
    int hit;
    int miss;
    int isLeaf;
    int leftChildLeaf;
	int rightChildLeaf;
    int3 topChildLeaf;
    int3 bottomChildLeaf;
    int indexedId;
    float2 padding;
};

struct MortonCode
{
    uint mortonCode;
    int particleIndex;
    uint index;
};

StructuredBuffer<MeshObject> _MeshObjects;
StructuredBuffer<Vertex> _Vertices;
StructuredBuffer<int> _Indices;
RWStructuredBuffer<Particle> _Particles;
RWStructuredBuffer<int> _ParticleIndices;
RWStructuredBuffer<int> _ParticleCellIndices;
RWStructuredBuffer<int> _ParticleCellOffsets;
RWStructuredBuffer<int> _ParticleCount;
RWStructuredBuffer<float3> _ParticlesPositions;
RWStructuredBuffer<MortonCode> _MortonCodes;
RWStructuredBuffer<MortonCode> _MortonCodesTemp;
RWStructuredBuffer<BVHNode> _BVHNodes;
RWStructuredBuffer<int> _ParticleIDs;
uint numOfStructs, sizeOfStrides, numOfParticles, sizeOfParticlesStrides;
float density = 0.0;
int _BoxViewDebug;
RWStructuredBuffer<uint> _MortonPrefixSumTotalZeroes;
RWStructuredBuffer<uint> _MortonPrefixSumOffsetZeroes;
RWStructuredBuffer<uint> _MortonPrefixSumOffsetOnes;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> DensityMap;
RWTexture2D<float4> NormalMap;

RWTexture2D<float4> _ColorFieldNormalMap;
RWTexture2D<float4> _VelocityMap;
RWTexture2D<float4> _CurlMap;
RWTexture2D<float4> _SurfaceMap;
RWTexture2D<float4> _VelocitySurfaceDensityDepthTexture;

Vertex CreateVertex(inout Vertex v)
{
    v.position = float3(0, 0, 0);
    v.normal = float3(0, 0, 0);
    v.uv = float2(0, 0);
    return v;
}


Ray CreateRay(float3 og, float3 dir, float2 pixel)
{
    Ray ray;
    ray.o = og;
    ray.d = dir;
    ray.color = float3(1, 1, 1);
    ray.energy = float3(0, 0, 0);
    ray.bounces = 0;
    return ray;
}

Hit CreateHit()
{
    Hit hit;
    hit.normal = 0;
    hit.position = 0;
    hit.distance = 1500;
    hit.color = float3(0, 0, 0);
    hit.depth = 0;

    Vertex v0, v1, v2;
    CreateVertex(v0);
    CreateVertex(v1);
    CreateVertex(v2);
    hit.vertices[0] = v0;
    hit.vertices[1] = v1;
    hit.vertices[2] = v2;

    hit.uv = 0;
    hit.meshObj = _MeshObjects[0];
    
    return hit;
}

BVHNode CreateBVH()
{
    BVHNode bvh;
	bvh.aabbMin = float3(0, 0, 0);
	bvh.aabbMax = float3(0, 0, 0);
	bvh.leftChild = 0;
	bvh.rightChild = 0;
	bvh.topChild = int3(0, 0, 0);
	bvh.bottomChild = int3(0, 0, 0);
	bvh.parent = -1;
	bvh.primitiveOffset = 0;
	bvh.primitiveCount = 0;
	bvh.index = 0;
	bvh.hit = 0;
	bvh.miss = 0;
    bvh.isLeaf = false;
	bvh.leftChildLeaf = -1;
	bvh.rightChildLeaf = -1;
	bvh.topChildLeaf = int3(-1, -1, -1);
	bvh.bottomChildLeaf = int3(-1, -1, -1);
	bvh.indexedId = -1;
	bvh.padding = float2(0, 0);
	return bvh;
}



float4x4 translate(float3 p)
{
    return float4x4 (1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        p.x, p.y, p.z, 1.0);
}

float Poly6Kernel(float distance2)
{
    float result = 0.0;
    float h = 1;

    if (0.0f < distance2 && distance2 < h)
    {

        float h9 = pow(h, 9.0f);
        float constPoly6 = 315.0f / (64.0f * UNITY_PI * h9);
        float poly6 = constPoly6 * pow((h * h) - (distance2 * distance2), 3.0f);
        result = poly6;
    }
    return result;
}

float3 Poly6GradientKernel(float distance2, float3 direction)
{
    float3 result = 0.0;
    float h = 1;

    float h9 = pow(h, 9.0f);
    float constPoly6 = -945.0f / (32.0f * UNITY_PI * h9);
    float3 poly6 = constPoly6 * direction * pow((h * h) - (distance2 * distance2), 2.0f);
    result = poly6;
    return result;
}

float SpikyKernelD1(float distance)
{
	float h6 = pow(_Radius, 6.0f);
	float spikyConst = 45.0f / (UNITY_PI * h6);
	float spikyKern = spikyConst * pow(_Radius - distance, 2.0f);
    return spikyKern;
}

float SpikyKernelD2(float distance)
{
	float h = 1.0f - distance / _Radius;
    return 90.0f / (UNITY_PI * pow(_Radius, 5.0f)) * h;
}

float3 SpikyKernelGradient(float distance2, float3 direction)
{
    float3 result = 0.0;
    float h = 1;
    if (0.0f  < distance2 && distance2 < h)
    {
        float m = pow(h - distance2, 2.0f);
        float h6 = pow(h, 6.0f);
        float spikyConst = -45.0f / (UNITY_PI);
        float3 spikyKern = (spikyConst * m / (h6 * distance2)) * direction;
        result = spikyKern;
    }
    return result;
}

Ray CreateCameraRay(float2 uv)
{
	//Get the world position of the origin, which is basically just the camera.
	// Last column contains position, take that.
    float3 og = mul(_CameraInverseProjection, float4(uv, -1, 1)).xyz;
    og = mul(_CameraToWorld, float4(og, 1)).xyz;

	//The scene has a depth to it. The project matrix takes the depth and places it flat onto a 2D plane.
	//The inverse projection does this process backwards. By multiplying it we go backwards.
    float3 dir = float3(0,0,0);
    dir = worldSpaceViewForward;
    if (_IsOrthographic)
        dir = worldSpaceViewForward;
    else
    {
        dir = mul(_CameraInverseProjection, float4(uv, -1, 1)).xyz;
        dir = mul(_CameraToWorld, float4(dir, 0)).xyz; //Take this 3D pixel point and make it world position.
    }
    

    dir = normalize(dir);
    return CreateRay(og, dir, uv);
}

int3 GetCell(float3 position)
{
    float3 halfS = _BoxSize / 2;
    return int3((position.x + halfS.x) / _Radius, (position.y + halfS.y) / _Radius, (position.z + halfS.z) / _Radius);
}

inline uint HashCell(in int3 cellIndex)
{
	const uint p1 = 73856093;
	const uint p2 = 19349663;
	const uint p3 = 83492791;
    
	uint n = p1 * cellIndex.x ^ p2 * cellIndex.y ^ p3 * cellIndex.z;
	n %= _NumOfParticles;
    return n;
}

//Moller method.
bool TriangleTrace(Ray ray, float3 a, float3 b, float3 c, inout float t, inout float u, inout float v)
{
    float3 edge1 = b - a;
    float3 edge2 = c - a;

    float3 pvec = cross(ray.d, edge2);

    float determinate = dot(edge1, pvec);

    if (determinate < epsilon)
        return false;

    float3 tvec = ray.o - a;
    float inv_det = 1.0 / determinate;

    u = dot(tvec, pvec) * inv_det;
    if (u < 0.0 || u > 1.0)
    {
        return false;
    }

    float3 qvec = cross(tvec, edge1);
    v = dot(ray.d, qvec) * inv_det;
    if (v < 0.0 || u + v > 1.0)
    {
        return false;
    }

    //Final calculate of T after crammer's rule.
    t = dot(edge2, qvec) * inv_det;

    return true;
}


//Ray slabs test for AABB.
bool TraceAABB(inout Ray ray, inout Hit hit, MeshObject meshObject)
{
    float3 invRayDir = 1.0 / ray.d;
    float3 tLower = (meshObject.AABBMin - ray.o) * invRayDir;
    float3 tUpper = (meshObject.AABBMax - ray.o) * invRayDir;

    float4 tMin = float4(min(tLower, tUpper), 0);
    float4 tMax = float4(max(tLower, tUpper), 10000000);

    //get max component of tMin.
    float tBoxMin = max(max(tMin.x, tMin.y), tMin.z);
    //get min component of tMax.
    float tBoxMax = min(min(tMax.x, tMax.y), tMax.z);

	return (tBoxMin <= tBoxMax) && (tBoxMax < 99999) && (tBoxMin > epsilon);
}

bool TraceBVH(inout Ray ray, inout Hit hit, BVHNode node)
{
    float3 invRayDir = 1.0 / ray.d;
    float3 tLower = (node.aabbMin - ray.o) * invRayDir;
    float3 tUpper = (node.aabbMax - ray.o) * invRayDir;

    float4 tMin = float4(min(tLower, tUpper), 0);
    float4 tMax = float4(max(tLower, tUpper), 10000000);

    //get max component of tMin.
    float tBoxMin = max(max(tMin.x, tMin.y), tMin.z);
    //get min component of tMax.
    float tBoxMax = min(min(tMax.x, tMax.y), tMax.z);

    return (tBoxMin <= tBoxMax);
}

float TraceBVHF(inout Ray ray, inout Hit hit, BVHNode node)
{
    float3 invRayDir = 1.0 / ray.d;
    float3 tLower = (node.aabbMin - ray.o) * invRayDir;
    float3 tUpper = (node.aabbMax - ray.o) * invRayDir;

    float4 tMin = float4(min(tLower, tUpper), 0);
    float4 tMax = float4(max(tLower, tUpper), 10000000);

    //get max component of tMin.
    float tBoxMin = max(max(tMin.x, tMin.y), tMin.z);
    //get min component of tMax.
    float tBoxMax = min(min(tMax.x, tMax.y), tMax.z);

    if (tBoxMin <= tBoxMax)
        return tBoxMin;
    return 9999999;
}

bool TraceMesh(inout Ray ray, inout Hit hit, MeshObject meshObject)
{
    uint offset = meshObject.indicesOffset;
    uint count = offset + meshObject.indicesCount;
    float3 tuv = 0;

    for (uint i = offset; i < count; i += 3)
    {
        float3 vp0 = (mul(meshObject.localToWorld, float4(_Vertices[_Indices[i]].position, 1))).xyz;
        float3 vp1 = (mul(meshObject.localToWorld, float4(_Vertices[_Indices[i + 1]].position, 1))).xyz;
        float3 vp2 = (mul(meshObject.localToWorld, float4(_Vertices[_Indices[i + 2]].position, 1))).xyz;

        if (TriangleTrace(ray, vp0, vp1, vp2, tuv.x, tuv.y, tuv.z))
        {
            float t = tuv.x;
            if (t > 0 && t < hit.distance)
            {
                //float3 PointPosition = (mul(meshObject.localToWorld, float4(ray.o + t * ray.d, 1))).xyz;
                //Set the vertices
                hit.vertices[0] = _Vertices[_Indices[i]];
                hit.vertices[1] = _Vertices[_Indices[i + 1]];
                hit.vertices[2] = _Vertices[_Indices[i + 2]];
                hit.distance = t;
                hit.uv = float2(tuv.y, tuv.z);
                hit.position = ray.o + t * ray.d;
                hit.meshObj = meshObject;
                return true;
            }
        }
    }
    return false;
}

//Gets how many particles are in this ray, from main directional light to last particle.
float GetDensityOfParticle(in Hit hit, in Ray ray)
{
    int particleDensity = 0; //This will be the density later on.
    float squaredDepthOfParticle = sqrt(numOfParticles)*25;

    for (int i = 0; i < numOfParticles; i++)
    {
        //Shoot ray to the direction of the light.
        float3 rayOrig = hit.position; //Start from the hit position, then shoot towards light.
        float3 rayDir = normalize(_LightSource - rayOrig);
		float3 center = _Particles[i].position;
        
        rayDir = normalize(_LightSource - rayOrig);
        //center = mul(_ParentTransform, float4(center, 1)).xyz;
        
        float t1 = sphIntersect(rayOrig, rayDir, float4(center, 0.5));
        
        //If it hit a particle add that to the total number of particles to obtain density.
        if (t1 > epsilon)
        {
            //New point is now the nearest particle.
            rayOrig = rayOrig + rayDir * (t1 + epsilon * 100);

            particleDensity++;
        }
    }

    //Now we do an attenuation, which is the y/x^2.
    return 2.55* particleDensity / (squaredDepthOfParticle);
    
}

//Intersects particles with the ray being casted. Used to render particles.
float IntersectParticles(inout Hit hit, in Ray ray, float radius, float3 center)
{
	float3 rayOrig = ray.o;
	float3 rayDir = ray.d;
	//center = mul(_ParentTransform, float4(center, 1)).xyz;

    //Get box transformation matrix.
	//float4x4 tra = translate(center);
    //float4x4 txi = tra;
    //float4x4 txx = inverse2(txi);
    //float t1 = 0;
	//float3 rad = float3(radius, radius, radius);
    
    //Intersect with a box and then smoothly combine boxes together with union operation.
    float4 tNFnorm = sphIntersect(rayOrig, rayDir, float4(center, radius));//boxIntersection2(rayOrig, rayDir, txx, txi, rad);//sphIntersect(rayOrig, rayDir, float4(center, rad.x));//boxIntersection2(rayOrig, rayDir, txx, txi, rad);
	float t1 = tNFnorm.x;
    t1 = opU(t1, hit.distance);
    
    return t1;
}

int nextNode(in BVHNode node, in Ray ray, in Hit hit, int nodeIndex)
{
    if(node.leftChild != -1)
	{
		return node.leftChild;
	}
    if (node.rightChild != -1)
    {
        return node.rightChild;
    }

    while (node.parent > -1)
    {
        //If I am the left child, and my parent has right child...go to the right child.
        if (node.index == _BVHNodes[node.parent].leftChild && _BVHNodes[node.parent].rightChild != -1)
        {
            return _BVHNodes[node.parent].rightChild;
        }
        node = _BVHNodes[node.parent];
    }

    return -1;
}

float TraceParticlesBVH(inout Ray ray, inout Hit hit)
{
    float minDistance = 99999999;

    int nodeIndex = 0;
    int currentNode = 0;
    BVHNode node = _BVHNodes[currentNode];
    bool particleHit = false;
    
    int numOfTimes = 0;
    while (particleHit == false)
    {

        if (node.primitiveCount > 0 )
        {
            if (TraceBVH(ray, hit, node))
            {
                for (int k = node.primitiveOffset; k < node.primitiveCount + node.primitiveOffset; k++)
                {
                    float3 position = _Particles[_ParticleIDs[k]].position;

                    float t1 = IntersectParticles(hit, ray, _SizeOfParticle, position);

                    if (t1 > epsilon && t1 < minDistance)
                    {
                        hit.distance = t1;
                        minDistance = t1;
                    }
                    numOfTimes++;
                }
                //particleHit = true;

                
            }
            currentNode = nextNode(node, ray, hit, currentNode);
        }
        else if (!TraceBVH(ray, hit, _BVHNodes[node.leftChild]) && node.rightChild != -1)
        {
            numOfTimes++;
            currentNode = node.rightChild;
        }
        else if (!TraceBVH(ray, hit, _BVHNodes[node.rightChild]) && node.leftChild != -1)
        {
            numOfTimes++;
            currentNode = node.leftChild;
        }
        else
        {
            numOfTimes++;
            currentNode = nextNode(node, ray, hit, currentNode);
        }
        nodeIndex++;

        //currentNode = nextNode(node, ray, hit, currentNode);
        node = _BVHNodes[currentNode];

        if (nodeIndex >= numOfParticles || currentNode == -1)
        {
            particleHit = true;
            break;
        }
    }
    
    return minDistance;
}

float TraceParticlesBVHIterative(inout Ray ray, inout Hit hit)
{
    float minDistance = 99999999;
    BVHNode node = _BVHNodes[0];
    for (int i = 0; i < _NumOfNodes; i++)
    {
		node = _BVHNodes[i];
        if (TraceBVH(ray, hit, node))
        {
            if (node.primitiveCount > 0)
            {
                for (int k = node.primitiveOffset; k < node.primitiveCount + node.primitiveOffset; k++)
                {
                    float3 position = _Particles[_ParticleIDs[k]].position;

                    float t1 = IntersectParticles(hit, ray, _SizeOfParticle, position);

                    if (t1 > epsilon && t1 < minDistance)
                    {
                        minDistance = t1;
                    }
                }
            }
        }
    }
	return minDistance;
}

float4 TraceParticlesTBVH(inout Ray ray, inout Hit hit)
{
    float minDistance = 99999999;
	float minBVHDistance = 99999999;
    int bvhminIndex = -1;
    int nodeIndex = 0;
	int particleIndex = -1;
    float particlesHit = 0;
    BVHNode node = _BVHNodes[0];
    int skip = 0;
    for (int i = 0; i < _NumOfNodes; i++)
    {

        node = _BVHNodes[nodeIndex];
        //Find next node.
        if (node.indexedId != i)
            continue;
        if (TraceBVH(ray, hit, node))
        {
            if(node.isLeaf > 0)
            //for (int k = node.primitiveOffset; k <= node.primitiveOffset + node.primitiveCount; k++)
            {
                
                float3 positionR = 9999999;
				if (node.rightChildLeaf > -1)
					positionR = _Particles[node.rightChildLeaf].position;
                float3 positionL = 9999999;
                
                if (node.leftChildLeaf > -1)
                    positionL = _Particles[node.leftChildLeaf].position;

                float t1 = IntersectParticles(hit, ray, _SizeOfParticle, positionR);
                float t2 = IntersectParticles(hit, ray, _SizeOfParticle, positionL);
                float t3 = 999999;

                if (t1 < 0)
                    t1 = 9999999;
                if (t2 < 0)
                    t2 = 9999999;

                float3 position;
                int particleID;
                
				if ((t1 < t2))
				{
                    t3 = t1;
					particleID = node.rightChildLeaf;
					position = positionR;
				}
				else
				{
                    t3 = t2;
					particleID = node.leftChildLeaf;
					position = positionL;
				}
                //t3 = t1;
                if (t3 > epsilon)
                {
                    particlesHit += 1.0f;
                    if (t3 < hit.distance)
                    {
                        float4 clipPos = UnityWorldToClipPos(position);
                        float depth = (clipPos.z * _DepthScale.x) / (clipPos.w * _DepthScale.y);
                        hit.depth = 1.0 - depth;
                        hit.distance = t3;
                        particleIndex = particleID;
                    }
                }
            }
            nodeIndex = node.hit;
        }
        else
        {

            nodeIndex = node.miss;
        }

    }
            
    float kd = min(99.0f, particlesHit) * 0.0055f;
    float e = exp(kd);
    float hitMap = e - 1.0f;
    return float4(minDistance, hitMap, particlesHit, particleIndex);
}


#define STACK_SIZE 15
#define WORK_GROUP_SIZE 256
int WORK_GROUP_SIZE_SQUAREDROOT = sqrt(WORK_GROUP_SIZE);

groupshared int stack[WORK_GROUP_SIZE][STACK_SIZE];


//Stack operations

void StackPush(int value, int offset)
{
    [unroll]
    for (int i = 0; i < STACK_SIZE; i++)
    {
        if (stack[offset][i] == -1)
        {
            stack[offset][i] = value;
            break;
        }
    }
}

int StackPop(int offset)
{
    int value = -1;
    [unroll]
    for (int i = STACK_SIZE - 1; i >= 0; i--)
    {
        if (stack[offset][i] != -1)
        {
            value = stack[offset][i];
            stack[offset][i] = -1;
            break;
        }
    }
    return value;
}

void CreateStack(int offset)
{
    [unroll]
    for (int i = 0; i < STACK_SIZE; i++)
    {
        stack[offset][i] = -1;
    }
}


float4 TraceParticlesStack(inout Ray ray, inout Hit hit, int newIndex)
{
    float minDistance = 99999999;
    float minBVHDistance = 99999999;
    int bvhminIndex = -1;
    int nodeIndex = 0;
    int particleIndex = -1;
    float particlesHit = 0;

    
    //int stack[STACK_SIZE];
    CreateStack(newIndex);
    StackPush(0, newIndex);
    int sum = 0;
    
    int counter = 0;
    while (stack[newIndex][0] > -1 && counter < _NumOfParticles)
    {
        
        nodeIndex = StackPop(newIndex);
        //GroupMemoryBarrier();
        sum += nodeIndex;

        BVHNode node = _BVHNodes[nodeIndex];
        if (TraceBVH(ray, hit, node))
        {
            if (node.isLeaf > 0)
            {

                float3 positionR = 9999999;
                if (node.rightChildLeaf > -1)
                    positionR = _Particles[node.rightChildLeaf].position;
                float3 positionL = 9999999;

                if (node.leftChildLeaf > -1)
                    positionL = _Particles[node.leftChildLeaf].position;

                float t1 = IntersectParticles(hit, ray, _SizeOfParticle, positionR);
                float t2 = IntersectParticles(hit, ray, _SizeOfParticle, positionL);
                float t3 = 999999;

                if (t1 < 0)
                    t1 = 9999999;
                if (t2 < 0)
                    t2 = 9999999;

                float3 position;
                int particleID;

                if ((t1 < t2))
                {
                    t3 = t1;
                    particleID = node.rightChildLeaf;
                    position = positionR;
                }
                else
                {
                    t3 = t2;
                    particleID = node.leftChildLeaf;
                    position = positionL;
                }
                //t3 = t1;
                if (t3 > epsilon)
                {
                    particlesHit += 1.0f;
                    if (t3 < hit.distance)
                    {
                        float4 clipPos = UnityWorldToClipPos(position);
                        float depth = (clipPos.z * _DepthScale.x) / (clipPos.w * _DepthScale.y);
                        hit.depth = 1.0 - depth;
                        hit.distance = t3;
                        particleIndex = particleID;
                    }
                }
            }


            if (node.leftChild > -1)
            {
                StackPush(node.leftChild, newIndex);
            }

            if (node.rightChild > -1)
            {
                StackPush(node.rightChild, newIndex);
            }
        }
        
        counter++;
    }
    
    float kd = min(99.0f, particlesHit) * 0.0055f;
    float e = exp(kd);
    float hitMap = e - 1.0f;
    return float4(minDistance, hitMap, particlesHit, particleIndex);
}

float4 TraceParticlesTBVHDebug(inout Ray ray, inout Hit hit)
{
    float minDistance = 99999999;
    float minBVHDistance = 99999999;
    int bvhminIndex = -1;
    int nodeIndex = 0;
    int particleIndex = -1;
    float particlesHit = 0;
    BVHNode node = _BVHNodes[0];
    for (int i = 0; i < _NumOfNodes; i++)
    {
        node = _BVHNodes[nodeIndex];
        if (TraceBVH(ray, hit, node))
        {
            return 1;
        }

    }
    return 0;
}

float TraceParticlesIterative(inout Ray ray, inout Hit hit)
{
    float minDistance = 99999999;
    for (int k = 0; k < _NumOfParticles; k++)
    {
        float3 position = _Particles[k].position;

        float t1 = IntersectParticles(hit, ray, _SizeOfParticle, position);

        if (t1 > epsilon && t1 < minDistance)
        {
            float4 clipPos = UnityWorldToClipPos(position);
            float depth = (clipPos.z * _DepthScale.x) / (clipPos.w * _DepthScale.y);
            hit.depth = 1.0 - depth;
            hit.distance = t1;;
            minDistance = t1;
        }
    }
    return minDistance;
}

float4 SceneTrace(inout Ray ray, inout Hit hit, out int particleId, out float particlesHit, int newIndex)
{

    float4 result = 99999999;
    float minDistance = 99999999;
	particleId = -1;
    particlesHit = 0.0f;

    for (int k = 0; k < numOfStructs; k++)
    {
        MeshObject meshObject = _MeshObjects[k];
        if (TraceAABB(ray, hit, meshObject) == true)
        {
            TraceMesh(ray, hit, meshObject);
        }

    }
    
    //result = TraceParticlesIterative(ray,hit);
    //result = TraceParticlesTBVH(ray, hit);
    result = TraceParticlesStack(ray, hit, newIndex);
    //return TraceParticlesTBVHDebug(ray, hit);
	minDistance = result.x;
	particlesHit = result.y;
	particleId = result.w;
    float3 position = ray.o + hit.distance * ray.d;

    if (_IsOrthographic)
    {
        hit.depth *= 100;
    }
    return float4(position.xyz, hit.depth);
    
}

// Expands a 10-bit integer into 30 bits
// by inserting 2 zeros after each bit.
unsigned int expandBits(unsigned int v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

// Calculates a 30-bit Morton code for the
// given 3D point located within the unit cube [0,1].
unsigned int morton3D(float x, float y, float z)
{
    x = min(max(x * 1024.0f, 0.0f), 1023.0f);
    y = min(max(y * 1024.0f, 0.0f), 1023.0f);
    z = min(max(z * 1024.0f, 0.0f), 1023.0f);
    unsigned int xx = expandBits((unsigned int)x);
    unsigned int yy = expandBits((unsigned int)y);
    unsigned int zz = expandBits((unsigned int)z);
    return xx * 4 + yy * 2 + zz;
}

int commonPrefixClz(int first, int last)
{
	if (first > _NumOfParticles-1 || first < 0 || last > _NumOfParticles -1|| last < 0)
	{
        return -1;
	}
    unsigned int firstCode = _MortonCodes[first].mortonCode;
    unsigned int lastCode = _MortonCodes[last].mortonCode;


    
    uint commonPrefix = clz(firstCode ^ lastCode);

    if (firstCode == lastCode)
    {
        //Since if they're equal clz == 32 bits, we look at index as tie breaker.
        commonPrefix += clz(first ^ last);
    }
    
    return commonPrefix;
}

int commonPrefixClz2(int first, int last)
{
    unsigned int firstCode = _MortonCodes[first].mortonCode;
    unsigned int lastCode = _MortonCodes[last].mortonCode;

    uint commonPrefix = clz(firstCode ^ lastCode);

    if (firstCode == lastCode)
    {
        //Since if they're equal clz == 32 bits, we look at index as tie breaker.
        commonPrefix += clz(first ^ last);
    }

    return commonPrefix;
}

int findSplit(int first, int last)
{
    // Identical Morton codes => split the range in the middle.
    unsigned int firstCode = _MortonCodes[first].mortonCode;
    unsigned int lastCode = _MortonCodes[last].mortonCode;
    
    
    //if (firstCode == lastCode)
    //    return (first + last) >> 1;

    // Calculate the number of highest bits that are the same
    // for all objects, using the count-leading-zeros intrinsic.

    uint commonPrefix = commonPrefixClz2(first, last);

    // Use binary search to find where the next bit differs.
    // Specifically, we are looking for the highest object that
    // shares more than commonPrefix bits with the first one.

    int split = first; // initial guess
    int step = last - first;

    do
    {
        step = (step + 1) >> 1; // exponential decrease
        int newSplit = split + step; // proposed new position

        if (newSplit < last)
        {
            unsigned int splitCode = _MortonCodes[newSplit].mortonCode;
            int splitPrefix = commonPrefixClz2(first, newSplit);
            if (splitPrefix > commonPrefix)
                split = newSplit; // accept proposal
        }
    } while (step > 1);

    return split;
}

uint2 determineRange(int idx)
{
    //Get the direction towards the upper bound.

    int direction = sign(commonPrefixClz(idx, idx + 1) - commonPrefixClz(idx, idx - 1));

    //Subtracting that direction gives us the lower bound, ie the lowest level for this node.
    int sigMin = commonPrefixClz(idx, idx - direction);



    int sigMax = 2;
    while (commonPrefixClz(idx, idx + sigMax * direction) > sigMin)
    {
        sigMax *= 2;
    }


    int sig = 0;
    for (int t = sigMax / 2; t >= 1; t /= 2)
    {
        if (commonPrefixClz(idx, idx + (sig + t) * direction) > sigMin)
        {
            sig += t;
        }
    }
    int j = idx + sig * direction;

    uint2 range;
    range.x = min(idx, j);
    range.y = max(idx, j);

    return range;
}

void CollisionTrace(inout Ray ray, inout Hit hit)
{
    for (int k = 0; k < numOfStructs; k++)
    {
        MeshObject meshObject = _MeshObjects[k];
        if (TraceAABB(ray, hit, meshObject) == true)
        {
            TraceMesh(ray, hit, meshObject);
        }

    }

    MeshObject meshObject = hit.meshObj;
    Vertex v0 = hit.vertices[0];
    Vertex v1 = hit.vertices[1];
    Vertex v2 = hit.vertices[2];
    //Convert to world space along with ray and compute the barycentric coordinate.
    v0.position = (mul(meshObject.localToWorld, float4(v0.position, 1))).xyz;
    v1.position = (mul(meshObject.localToWorld, float4(v1.position, 1))).xyz;
    v2.position = (mul(meshObject.localToWorld, float4(v2.position, 1))).xyz;
    v0.normal = (mul(meshObject.localToWorld, float4(v0.normal, 0))).xyz;
    v1.normal = (mul(meshObject.localToWorld, float4(v1.normal, 0))).xyz;
    v2.normal = (mul(meshObject.localToWorld, float4(v2.normal, 0))).xyz;
    float3 barycentric = Barycentric(v0.position, v1.position, v2.position, hit.position);

    //Now that we have the barycentric coordinate we can use this to reconstruct the UVs.
    float2 uvs = v0.uv * barycentric.x + v1.uv * barycentric.y + v2.uv * barycentric.z;

    float3 normals = normalize(v0.normal * barycentric.x + v1.normal * barycentric.y + v2.normal * barycentric.z);

    hit.normal = normals;
    hit.uv = uvs;
    
}

[numthreads(16,16,1)]
void CreateGrid (uint3 id : SV_DispatchThreadID, uint3 GroupThreadID : SV_GroupThreadID)
{
    
    //Resets all values.
    uint width, height;
    int particleId = -1;
    float particlesHit = 0;
    density = 0;
    _VelocityMap[id.xy] = 0;
    _VelocitySurfaceDensityDepthTexture[id.xy] = 0;
    _ColorFieldNormalMap[id.xy] = 0;
    _CurlMap[id.xy] = 0;
    _SurfaceMap[id.xy] = 0.0f;

	//Gets the dimensions of the screen.
    Result.GetDimensions(width, height);
    worldSpaceViewForward = -UNITY_MATRIX_I_V._m02_m12_m22;
    _MeshObjects.GetDimensions(numOfStructs, sizeOfStrides);
    _Particles.GetDimensions(numOfParticles, sizeOfParticlesStrides);


	//This is a ray for each pixel and in the pixel's center.
	//So id.xy is this pixel, then offsetted to center, then divided by the width and height to get said center.
	//Then range is shifted via 2 - 1.
    float2 pixel = ((id.xy + float2(0.5, 0.5)) / float2(width, height)) * 2 - 1; //Note in HLSL this vector v - scalar is applied to each element in v.
    Ray ray = CreateCameraRay(pixel);
    Hit hit = CreateHit();

    //Actually perform intersection.
    float4 tracedPoint = SceneTrace(ray, hit, particleId, particlesHit, GroupThreadID.x + GroupThreadID.y * 16);
    Result[id.xy] = float4(tracedPoint.xyz, tracedPoint.w);
    DensityMap[id.xy] = particlesHit;

    if (particleId >= 0)
    {
		Particle particle = _Particles[particleId];
        //Check if this particle has any particle on its sides.

        //Calculate the surface, and fade away.
		//TODO: do all sides of the main axis.
        Ray raySides = CreateCameraRay(pixel);
        Hit hitSides = CreateHit();
        float minDistance = 99999999;
		float4 result = 99999999;
		float3 freeSurface = 0;
        raySides.o = particle.position;
		raySides.d = float3(0.0f,1.0f,0.0f);
        /*
        result = TraceParticlesStack(raySides, hitSides, id);
        if (result.z < 3.00f && particle.neighborCount > 0)
            freeSurface += raySides.d;
        

        raySides.d = float3(0.0f, 0.0f, 1.0f);
        result = 99999999;
        result = TraceParticlesStack(raySides, hitSides, id);
        freeSurface *= float3(0.0f, result.y, 0.0f);
        

        raySides.d = float3(0.0f, 0.0f, -1.0f);
        result = 99999999;
        result = TraceParticlesStack(raySides, hitSides, id);
        if (result.z < 3.00f)
            freeSurface *= float3(0.0f, 0.0f, 0.0f);

        freeSurface = 1;
        */
        freeSurface = particle.density/ _RestDensity;
        _ColorFieldNormalMap[id.xy] = float4(particle.normal, 1);
        _SurfaceMap[id.xy] = float4(freeSurface, 1);
		_VelocityMap[id.xy] = float4(particle.velocity, length(particle.velocity) + length(_Particles[particleId].curl) * 0.055);
        _CurlMap[id.xy] = float4(_Particles[particleId].curl, 1);
        
    }
    
    _VelocitySurfaceDensityDepthTexture[id.xy] = float4(_VelocityMap[id.xy].w, _SurfaceMap[id.xy].y, DensityMap[id.xy].x, Result[id.xy].w);

}

[numthreads(64, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    //Good.
	if (id.x >= _NumOfParticles)
	{
		return;
	}

	float4 constantForces = float4(0.0, -9.8, 0.0, 0.0);
    _Particles.GetDimensions(numOfParticles, sizeOfParticlesStrides);
    float4 forces = _Particles[id.x].force +constantForces;
    float3 vel = _Particles[id.x].velocity;
    vel += forces.xyz * _TimeStep;
    _Particles[id.x].force = forces;
    _Particles[id.x].velocity = vel;
    _Particles[id.x].lastPosition = _Particles[id.x].position;
    _Particles[id.x].predictedPosition = _Particles[id.x].position + vel * _TimeStep;
    _Particles[id.x].debugVector = 0.25;
    _Particles[id.x].parent = -1;
}

void GetDensityIterative(uint3 id)
{
    int numOfParticles = _NumOfParticles;
    //Loop through all particles comparing it to current particle.
    float3 oPos = _Particles[id.x].position;
    float sum = 0;
    //Check if that particle is in the radius.
    for (int i = 0; i < numOfParticles; i++)
    {
        float distance2 = distance(oPos, _Particles[i].position);//dot(oPos -_Particles[i].position , oPos - _Particles[i].position );
        sum += Poly6Kernel(distance2) * _Particles[i].mass;

    }
}

void GetDensityGrid(uint3 id)
{
    int numOfParticles = _NumOfParticles;
    uint particleIndex = _ParticleIndices[id.x];
    int3 cellIndex = GetCell(_Particles[particleIndex].predictedPosition);
    float densitySum = 0;
    float dNorm = 0;
    float3 spiky_i = 0;
    float3 colorField = 0;
    for (int i = -2; i <= 2; ++i)
    {
        for (int j = -2; j <= 2; ++j)
        {
            for (int k = -2; k <= 2; ++k)
            {
				int3 neighbourIndex = cellIndex + int3(i, j, k);
				uint hashedNeighborIndex = HashCell(neighbourIndex);
                uint neighbourIterator = _ParticleCellOffsets[hashedNeighborIndex];

                while (neighbourIterator != 99999999 && neighbourIterator < _NumOfParticles)
                {
					uint particleIndexB = _ParticleIndices[neighbourIterator];
                    
					if (_ParticleCellIndices[particleIndexB] != hashedNeighborIndex)
					{
						break;
					}
                    
					Particle neighbour = _Particles[particleIndexB];
                    float distance2 = distance(_Particles[particleIndex].predictedPosition, _Particles[particleIndexB].predictedPosition);
                    float3 pressureGradDir = _Particles[particleIndex].predictedPosition - _Particles[particleIndexB].predictedPosition;
                    
                    if (0.001f < distance2 && distance2 < _Radius * 2)
                    {
                        //Poly6
                        densitySum += Poly6Kernel(distance2) * _Particles[particleIndex].mass;
                        //Spiky
						float3 spiky = SpikyKernelGradient(distance2, pressureGradDir) / _RestDensity;
						spiky_i += spiky;
                        dNorm += dot(spiky, spiky);
                        colorField += _Particles[particleIndexB].mass * (1 / _Particles[particleIndexB].density) * Poly6GradientKernel(distance2, pressureGradDir);
                        if (particleIndex == _ChosenParticle)
                        {
                            //Set to color red.
                            _Particles[particleIndex].debugVector = float3(1, 0, 0);
                            _Particles[particleIndexB].debugVector = float3(0, 1, 0);
                        }
                    }
                    neighbourIterator++;
                }
            }
        }
    }
    //densitySum *= 0.8250;
    float constraint = (densitySum / _RestDensity) - 1;
	dNorm += dot(spiky_i, spiky_i);
    float lambda = -constraint / (dNorm + 1000.0f);
    _Particles[particleIndex].density = densitySum;
    //_Particles[particleIndex].debugVector += float3(0, 0, 1) * (densitySum / _RestDensity);
	_Particles[particleIndex].lambda = lambda;
    _Particles[particleIndex].normal = min(normalize(-colorField), float3(1,1,1));
}

//Figure (1)
[numthreads(64, 1, 1)]
void ComputeDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles)
    {
        return;
    }
    
    GetDensityGrid(id);
}


[numthreads(64, 1, 1)]
void UpdatePositionDeltas(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles)
    {
        return;
    }
    
    int numOfParticles = _NumOfParticles;
    uint particleIndex = _ParticleIndices[id.x];
    int3 cellIndex = GetCell(_Particles[particleIndex].predictedPosition);

    float3 positionDelta = 0;
    

    for (int i = -2; i <= 2; ++i)
    {
        for (int j = -2; j <= 2; ++j)
        {
            for (int k = -2; k <= 2; ++k)
            {
                int3 neighbourIndex = cellIndex + int3(i, j, k);
                uint hashedNeighborIndex = HashCell(neighbourIndex);
                uint neighbourIterator = _ParticleCellOffsets[hashedNeighborIndex];

                while (neighbourIterator != 99999999 && neighbourIterator < _NumOfParticles)
                {
                    uint particleIndexB = _ParticleIndices[neighbourIterator];

                    if (_ParticleCellIndices[particleIndexB] != hashedNeighborIndex)
                    {
                        break;
                    }

                    if (particleIndexB == particleIndex)
                    {
                        neighbourIterator++;
                        continue;
                    }
                    
                    Particle neighbour = _Particles[particleIndexB];
                    float dist = distance(_Particles[particleIndex].predictedPosition, _Particles[particleIndexB].predictedPosition);

                    if (0.001f < dist && dist < _Radius * 2.0f)
                    {
                        float Scorr = -0.01 * pow(Poly6Kernel(dist) / Poly6Kernel(0.003*_Radius), 4);
                        float left = _Particles[particleIndex].lambda + _Particles[particleIndexB].lambda +Scorr;
						float3 right = SpikyKernelGradient(dist, _Particles[particleIndex].predictedPosition - _Particles[particleIndexB].predictedPosition);

                        positionDelta += left * right / _RestDensity;//left * right / _RestDensity;
                        if (particleIndex == _ChosenParticle)
                        {
                            //Set to color red.
                            //_Particles[particleIndex].debugVector = float3(1, 0, 0);
                            //_Particles[particleIndexB].debugVector = float3(0, 1, 0);
                        }
                    }
                    neighbourIterator++;
                }
            }
        }
    }
    //Correct position
	
    //_Particles[id.x].pressure = sum.x;
    //vel = vel * (positionDelta - _Particles[particleIndex].position) / _TimeStep;
    //vel = min(vel, float3(9999, 9999, 9999));
    _Particles[particleIndex].positionDelta = positionDelta;
	//a_Particles[particleIndex].curl = curl;
	//_Particles[particleIndex].velocity = vel;
    //_Particles[id.x].debugVector = sum;
}


//Based on the following paper: https://matthias-research.github.io/pages/publications/sca03.pdf
// Particle-Based Fluid Simulation for Interactive Applications
[numthreads(64, 1, 1)]
void UpdateParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles)
    {
        return;
    }
    
    _MeshObjects.GetDimensions(numOfStructs, sizeOfStrides);
    
    float3 positionDelta = _Particles[id.x].positionDelta + _Particles[id.x].predictedPosition;
    float3 boxSize = _BoxSize;
    float3 topRight = boxSize / 2;
    float3 bottomLeft = -boxSize / 2;

    if (positionDelta.x - _SizeOfParticle < bottomLeft.x)
    {
        positionDelta.x = bottomLeft.x + _SizeOfParticle;
    }
    if (positionDelta.y - _SizeOfParticle < bottomLeft.y)
    {
        positionDelta.y = bottomLeft.y + _SizeOfParticle;
    }
    if (positionDelta.z - _SizeOfParticle < bottomLeft.z)
    {
        positionDelta.z = bottomLeft.z + _SizeOfParticle;
    }


    //Max Boundary Enforcements
    if (positionDelta.x + _SizeOfParticle > topRight.x)
    {
        positionDelta.x = topRight.x - _SizeOfParticle;
    }
    if (positionDelta.y + _SizeOfParticle > topRight.y)
    {
        positionDelta.y = topRight.y - _SizeOfParticle;
    }
    if (positionDelta.z + _SizeOfParticle > topRight.z)
    {
        positionDelta.z = topRight.z - _SizeOfParticle;
    }

    _Particles[id.x].predictedPosition = positionDelta;
}

[numthreads(64, 1, 1)]
void CalculateCurl(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles)
    {
        return;
    }

    int numOfParticles = _NumOfParticles;
    uint particleIndex = _ParticleIndices[id.x];
    int3 cellIndex = GetCell(_Particles[particleIndex].predictedPosition);
    float3 curl = 0;
    
    for (int i = -2; i <= 2; ++i)
    {
        for (int j = -2; j <= 2; ++j)
        {
            for (int k = -2; k <= 2; ++k)
            {
                int3 neighbourIndex = cellIndex + int3(i, j, k);
                uint hashedNeighborIndex = HashCell(neighbourIndex);
                uint neighbourIterator = _ParticleCellOffsets[hashedNeighborIndex];

                while (neighbourIterator != 99999999 && neighbourIterator < _NumOfParticles)
                {
                    uint particleIndexB = _ParticleIndices[neighbourIterator];

                    if (_ParticleCellIndices[particleIndexB] != hashedNeighborIndex)
                    {
                        break;
                    }

                    if (particleIndexB == particleIndex)
                    {
                        neighbourIterator++;
                        continue;
                    }

                    Particle neighbour = _Particles[particleIndexB];
                    float dist = distance(_Particles[particleIndex].predictedPosition, _Particles[particleIndexB].predictedPosition);

                    if (0.0001f < dist && dist < _Radius * 2.0f)
                    {
						float3 u = _Particles[particleIndexB].velocity - _Particles[particleIndex].velocity;
						float3 v = SpikyKernelGradient(dist, _Particles[particleIndex].predictedPosition - _Particles[particleIndexB].predictedPosition);
						float3 w = cross(u, v);
                        curl += w;
                    }
                    neighbourIterator++;
                }
            }
        }
    }
    _Particles[particleIndex].curl = curl;
}

[numthreads(64, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles)
    {
        return;
    }
    
    _MeshObjects.GetDimensions(numOfStructs, sizeOfStrides);
    _Particles.GetDimensions(numOfParticles, sizeOfParticlesStrides);

	float3 sumVelocityVorticity = 0;
    float3 positionDelta = _Particles[id.x].predictedPosition;
    float3 velDamping = 1;

    float3 boxSize = _BoxSize;
    float3 topRight = boxSize / 2;
    float3 bottomLeft = -boxSize / 2;

    if (positionDelta.x - _SizeOfParticle < bottomLeft.x)
    {
        velDamping.x *= _BoundsDamping;
        positionDelta.x = bottomLeft.x + _SizeOfParticle;
    }
    if (positionDelta.y - _SizeOfParticle < bottomLeft.y)
    {
        velDamping.y *= _BoundsDamping;
        positionDelta.y = bottomLeft.y + _SizeOfParticle;
    }
    if (positionDelta.z - _SizeOfParticle < bottomLeft.z)
    {
        velDamping.z *= _BoundsDamping;
        positionDelta.z = bottomLeft.z + _SizeOfParticle;
    }

    //Max Boundary Enforcements
    if (positionDelta.x + _SizeOfParticle > topRight.x)
    {
        velDamping.x *= _BoundsDamping;
        positionDelta.x = topRight.x - _SizeOfParticle;
    }
    if (positionDelta.y + _SizeOfParticle > topRight.y)
    {
        velDamping.y *= _BoundsDamping;
        positionDelta.y = topRight.y - _SizeOfParticle;
    }
    if (positionDelta.z + _SizeOfParticle > topRight.z)
    {
        velDamping.z *= _BoundsDamping;
        positionDelta.z = topRight.z - _SizeOfParticle;
    }

    float2 pixel = ((id.xy + float2(0.5, 0.5)) / float2(1, 1)) * 2 - 1; //Note in HLSL this vector v - scalar is applied to each element in v.
    Ray ray = CreateCameraRay(pixel);
    Hit hit = CreateHit();

    ray.o = _Particles[id.x].lastPosition;
    ray.d = normalize(positionDelta - _Particles[id.x].lastPosition);

    CollisionTrace(ray, hit);

    if (hit.distance < abs(length(positionDelta - _Particles[id.x].lastPosition)) + _SizeOfParticle * 2)
    {
        //We hit something.
        float3 normal = hit.normal;
        positionDelta = ray.o + (ray.d * ( hit.distance- _SizeOfParticle * 2));
        velDamping = -normal * _BoundsDamping;
        //positionDelta = float3(0, 0, 0);
    }
    
    float3 vel = ((positionDelta - _Particles[id.x].lastPosition) / _TimeStep);
    
    _Particles[id.x].velocity = vel * velDamping;
	_Particles[id.x].position = positionDelta;
	_Particles[id.x].force.xyz *= _Particles[id.x].force.w;
    //_Particles[id.x].debugVector = ray.d;
}

[numthreads(64, 1, 1)]
void CalculateVorticity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles)
    {
        return;
    }


    int numOfParticles = _NumOfParticles;
    uint particleIndex = _ParticleIndices[id.x];
    int3 cellIndex = GetCell(_Particles[particleIndex].predictedPosition);
    float3 nVisc = 0;
    float3 velocities = 0;

    for (int i = -2; i <= 2; ++i)
    {
        for (int j = -2; j <= 2; ++j)
        {
            for (int k = -2; k <= 2; ++k)
            {
                int3 neighbourIndex = cellIndex + int3(i, j, k);
                uint hashedNeighborIndex = HashCell(neighbourIndex);
                uint neighbourIterator = _ParticleCellOffsets[hashedNeighborIndex];

                while (neighbourIterator != 99999999 && neighbourIterator < _NumOfParticles)
                {
                    uint particleIndexB = _ParticleIndices[neighbourIterator];

                    if (_ParticleCellIndices[particleIndexB] != hashedNeighborIndex)
                    {
                        break;
                    }

                    if (particleIndexB == particleIndex)
                    {
                        neighbourIterator++;
                        continue;
                    }

                    Particle neighbour = _Particles[particleIndexB];
                    float dist = distance(_Particles[particleIndex].predictedPosition, _Particles[particleIndexB].predictedPosition);

                    if (0.001f < dist && dist < _Radius * 2.0f)
                    {
                        float3 vij = _Particles[particleIndexB].velocity - _Particles[particleIndex].velocity;
                        //sumVelocityVorticity
                        nVisc += length(_Particles[particleIndexB].curl) * SpikyKernelGradient(dist, _Particles[particleIndex].predictedPosition - _Particles[particleIndexB].predictedPosition);

                        velocities += vij * Poly6Kernel(dist);
                    }
                    neighbourIterator++;
                }
            }
        }
    }

    float3 n_hat = 0;
    if (dot(nVisc, nVisc) > epsilon)
    {
        n_hat = (nVisc / length(nVisc));// *_Viscosity;
    }

    float3 f_vc = _Viscosity * cross(n_hat, _Particles[particleIndex].curl);
    float3 c = 0.001;
    
    //_Particles[particleIndex].velocity += c * velocities + f_vc * _TimeStep;
}

uint ConcatenateIndex(uint mortonCode, uint index, uint indexBitCount)
{
    // Shift the morton code to the left to make space for the index
    uint shiftedMortonCode = mortonCode << indexBitCount;

	index = index & ((1 << indexBitCount) - 1);

    // Assume index fits within indexBitCount bits and combine them
    return shiftedMortonCode | index;
}

[numthreads(256, 1, 1)]
void HashParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _MaxNumOfParticles)
    {
        return;
    }
    
    //_Particles[id.x].debugVector = 0.25;
    _ParticleCellOffsets[id.x] = 99999999;
	_ParticleCellIndices[id.x] = _MaxNumOfParticles -1;
    _ParticleIndices[id.x] = id.x;
    _ParticleCount[id.x] = 0;
    
    uint particleIndex = _ParticleIndices[id.x];
    
    if(id.x < _NumOfParticles)
        _ParticleCellIndices[particleIndex] = HashCell(GetCell(_Particles[particleIndex].predictedPosition));
    uint cellIndex = _ParticleCellIndices[particleIndex];
    
    InterlockedAdd(_ParticleCount[cellIndex], 1);

    float3 pos = (_Particles[id.x].position + _BoxSize) /(_BoxSize*2);
    uint testNums[] = { 30, 1, 5, 19, 5, 4,  5, 24 };
    //uint testNums[] = { 1, 3, 6, 2, 7, 8, 5, 4  };
     //uint testNums[] = { 6,2,8,4,1,3,7,5  };
     //uint testNums[] = { 8, 4, 1, 5, 6, 2, 3, 7 };
     //uint testNums[] = { 8, 1, 2, 3, 4, 5, 6, 7 };
    _MortonCodes[id.x].mortonCode = morton3D(pos.x, pos.y, pos.z);//ConcatenateIndex(morton3D(pos.x, pos.y, pos.z), id.x, 4);
    //_MortonCodes[id.x].mortonCode = ConcatenateIndex(testNums[id.x], id.x, 4);
    //_MortonCodes[id.x].mortonCode = testNums[id.x];
	_MortonCodes[id.x].particleIndex = id.x;
    _MortonCodes[id.x].index = id.x;

    _MortonCodesTemp[id.x].mortonCode = _MortonCodes[id.x].mortonCode;
	_MortonCodesTemp[id.x].particleIndex = _MortonCodes[id.x].particleIndex;
	_MortonCodesTemp[id.x].index = _MortonCodes[id.x].index;

}

[numthreads(256, 1, 1)]
void AssignMortonCodes(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= _NumOfParticles)
	{
		return;
	}

    _MortonPrefixSumOffsetOnes[id.x] = 0;

    int indexBit = firstbitlow(_MortonCodesTemp[id.x].mortonCode >> biBlock);
    if (indexBit == 0)
        _MortonPrefixSumOffsetOnes[id.x] = 1;
    else
    {
        _MortonPrefixSumOffsetOnes[id.x] = 0;
    }

    _MortonCodes[id.x].mortonCode = _MortonCodesTemp[id.x].mortonCode;
    _MortonCodes[id.x].particleIndex = _MortonCodesTemp[id.x].particleIndex;
	_MortonCodes[id.x].index = id.x;
}

[numthreads(256, 1, 1)]
void PrefixSum(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles)
    {
        return;
    }
    
    int nextStep = pow(2, biDim - 1);
    if (id.x - nextStep >= 0)
    {
        _MortonPrefixSumOffsetOnes[id.x] += _MortonPrefixSumOffsetOnes[id.x - nextStep];
    }
}

[numthreads(256, 1, 1)]
void BitonicSort(uint3 id : SV_DispatchThreadID)
{

    if (id.x >= _MaxNumOfParticles)
    {
        return;
    }

    uint index = _ParticleCellIndices[id.x];
    uint i = id.x + id.y * 256 * 1024;
    uint j = i ^ biBlock;

    if (j < i || i >= _MaxNumOfParticles)
        return;

    uint key_i = _ParticleIndices[i];
    uint key_j = _ParticleIndices[j];
    float value_i = _ParticleCellIndices[key_i];
    float value_j = _ParticleCellIndices[key_j];

    float diff = (value_i - value_j) * ((i & biDim) == 0 ? 1 : -1);
    if (diff > 0)
    {
        _ParticleIndices[i] = key_j;
        _ParticleIndices[j] = key_i;
    }

}

[numthreads(1024, 1, 1)]
void RadixSort(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles)
    {
        return;
    }
    
    int indexBit = firstbitlow(_MortonCodes[id.x].mortonCode >> biBlock);

    //If the bit LSB is 1.
    if (indexBit == 0)
    {
        //Place at bottom half of the list. which is after total number of zeroes.
        int index = _MortonPrefixSumOffsetOnes[id.x] + ((_NumOfParticles - 1) - _MortonPrefixSumOffsetOnes[_NumOfParticles - 1]);
        //_MortonCodes[id.x] = index;//testNums[index];
        _MortonCodesTemp[index].mortonCode = _MortonCodes[id.x].mortonCode;
        _MortonCodesTemp[index].particleIndex = _MortonCodes[id.x].particleIndex;
    }
    else {
        int index = id.x - _MortonPrefixSumOffsetOnes[id.x];
        //_MortonCodes[id.x] = index;//testNums[index];
        _MortonCodesTemp[index].mortonCode = _MortonCodes[id.x].mortonCode;
        _MortonCodesTemp[index].particleIndex = _MortonCodes[id.x].particleIndex;
    }
    //_MortonCodes[id.x] = testNumsSwap[id.x % 8];
    //_MortonCodesTemp[id.x].mortonCode = _MortonPrefixSumOffsetOnes[id.x];
}

[numthreads(256, 1, 1)]
void CalculateCellOffsets(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles)
    {
        return;
    }

    //_MortonCodes[id.x].mortonCode = _MortonCodesTemp[id.x].mortonCode;
    //_MortonCodes[id.x].particleIndex = _MortonCodesTemp[id.x].particleIndex;
    
    _ParticleIDs[id.x] = _MortonCodes[id.x].particleIndex;
    //_MortonCodes[id.x].particleIndex = id.x;
	uint particleIndex = _ParticleIndices[id.x];
	uint cellIndex = _ParticleCellIndices[particleIndex];

    //Make BVH here as well.
    BVHNode bvh = CreateBVH();
    bvh.aabbMin = _BoxSize;
    bvh.aabbMax = -_BoxSize;
    _BVHNodes[id.x] = bvh;

	//Sets this value at the index cellIndex. However it waits for all threads and ensures this is the minimum value at that index.
	InterlockedMin(_ParticleCellOffsets[cellIndex], id.x);
}


[numthreads(256, 1, 1)]
void CreateBVHTree(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles - 1)
    {
        return;
    }

    BVHNode bvh = _BVHNodes[id.x];
    bvh.index = id.x;
    bvh.indexedId = -1;

    uint2 range = determineRange(id.x);
    int gamma = findSplit(range.x, range.y);//id.x + s * direction + min(direction, 0);

    bvh.leftChild = gamma;
    bvh.primitiveOffset = min(range.x, range.y);

    bvh.rightChild = gamma + 1;
    bvh.primitiveCount = max(range.x, range.y) - min(range.x, range.y);
    bvh.isLeaf = false;

    if (min(range.x, range.y) == gamma)
    {
        _Particles[_ParticleIDs[gamma]].parent = id.x;
        bvh.isLeaf = true;
        bvh.leftChildLeaf = _ParticleIDs[gamma];
        bvh.leftChild = -1;
    }

    if (max(range.x, range.y) == gamma + 1)
    {
        _Particles[_ParticleIDs[gamma+1]].parent = id.x;
        bvh.isLeaf = true;
        bvh.rightChildLeaf = _ParticleIDs[gamma + 1];
        bvh.rightChild = -1;
    }
    /*
    uint2 rangeInitial = determineRange(0);
    int gammaInitial = findSplit(rangeInitial.x, rangeInitial.y);
    
	bvh.indexedId = (gammaInitial+1)-id.x;
    if (id.x >= gammaInitial + 1)
    {
        bvh.indexedId = id.x;
    }

    if(id.x == 0)
	{
		bvh.indexedId = 0;
	}
    */
    _BVHNodes[id.x] = bvh;
    _BVHNodes[0].parent = -1;


    
}

[numthreads(256, 1, 1)]
void AssignParents(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles - 1)
    {
        return;
    }

    BVHNode bvh = _BVHNodes[id.x];
    
    if (bvh.leftChild > -1)
    {
        _BVHNodes[bvh.leftChild].parent = id.x;
    }

    if (bvh.rightChild > -1)
    {
        _BVHNodes[bvh.rightChild].parent = id.x;
    }
}

[numthreads(256, 1, 1)]
void CreateBoundingBox(uint3 id : SV_DispatchThreadID)
{

    if (id.x >= _NumOfParticles - 1)
    {
        return;
    }
    
    BVHNode bvh = _BVHNodes[id.x];

    //Create bounding box.
	bvh.aabbMin = _BoxSize;
	bvh.aabbMax = -_BoxSize;


    for (int i = bvh.primitiveOffset; i <= bvh.primitiveCount + bvh.primitiveOffset; i++)
    {
        int particleIndex = _ParticleIDs[i];
        float3 particlePos = _Particles[particleIndex].position;
        float sizeOfParticleSquared = _SizeOfParticle+ _SizeOfParticle+ _SizeOfParticle*10;
        float3 sizeOfParticle = 1 * float3(sizeOfParticleSquared, sizeOfParticleSquared, sizeOfParticleSquared);
        bvh.aabbMin = min(bvh.aabbMin, particlePos - sizeOfParticle);
        bvh.aabbMax = max(bvh.aabbMax, particlePos + sizeOfParticle);
    }

    //Create hit and miss links.

    //Always next node in array.
    bvh.hit = -1;
    bvh.miss = -1;

    if (bvh.leftChild > -1)
    {
        bvh.hit = bvh.leftChild;
    }
    else if(bvh.rightChild > -1)
    {
        bvh.hit = bvh.rightChild;
    }

    
    if (id.x == 0)
    {
        _BVHNodes[id.x] = bvh;
        return;
    }

    //If final node make it terminal instead.
    /*
    if (id.x >= _NumOfParticles - 2)
    {
        bvh.hit = -1;
        bvh.miss = -1;
        _BVHNodes[id.x] = bvh;
        return;
    }
    */

    //Get miss links based on a few rules.
    //If a leaf
    /*
    if (bvh.isLeaf > 0)
    {
        bvh.miss = id.x + 1;
        _BVHNodes[id.x] = bvh;

        return;
    }
    */
    BVHNode node = bvh;
    int counter = 0;
    
	while (node.parent > -1 && counter < _NumOfParticles)
    {

        if (counter > _NumOfParticles - 2)
        {
            bvh.miss = -304;
            break;
        }
        
        if (node.index == _BVHNodes[node.parent].leftChild && _BVHNodes[node.parent].rightChild != -1)
        {
            bvh.miss = _BVHNodes[node.parent].rightChild;
            if(bvh.hit == -1)
			{
				bvh.hit = _BVHNodes[node.parent].rightChild;
			}
            break;
        }
        node = _BVHNodes[node.parent];
        counter++;
    }

    //Final fall back ;)
    if (bvh.hit == -1)
    {
        bvh.hit = id.x + 1;
    }
    
    _BVHNodes[id.x] = bvh;
}


[numthreads(1, 1, 1)]
void AssignIndex(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumOfParticles - 1)
    {
        return;
    }
    
    /*
    int stack[STACK_SIZE];
    CreateStack(stack);
    StackPush(stack, 0);
    int sum = 0;
	int nodeIndex = 0;
    
    int counter = 0;
	while (stack[0] > -1 && counter < _NumOfParticles)
    {
		nodeIndex = StackPop(stack);
        
        sum += nodeIndex;
        
        BVHNode node = _BVHNodes[nodeIndex];
        
        if(node.leftChild > -1)
		{
			StackPush(stack, node.leftChild);
		}
        
		if (node.rightChild > -1)
		{
			StackPush(stack, node.rightChild);
		}
        counter++;
    }

    _BVHNodes[id.x].indexedId = sum;
    */
    /*
    int index = 0;
    int currentNode = 0;
    int numOfP = _NumOfParticles - 1;
    int numOfP2 = _NumOfParticles - 2;
	for (int i = 0; i < numOfP; i++)
	{
        currentNode = index;
        _BVHNodes[currentNode].indexedId = i;
		index = _BVHNodes[currentNode].hit;
        
		if (i == numOfP2)
		{
			_BVHNodes[currentNode].hit = -1;
            _BVHNodes[currentNode].miss = -1;
		}
	}
    */
}