#pragma kernel CreateGrid
#pragma kernel UpdateParticles
#pragma kernel ComputeDensity
#pragma kernel ComputeForces
#pragma kernel SpacePartition

#include "../../ShaderHelpers.hlsl"
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 _ParentTransform;
float4x4 _CameraWorldToLocal;
float4x4 _ParentTransformToLocal;

float epsilon = 0.00001;
float _SizeOfParticle;
float _Smoothness;
float4 _DepthScale = 1;
float3 _LightSource;
float3 _LightScale;
float3 worldSpaceViewForward;
bool _IsOrthographic;
float _Radius = 1;
float _GasConstant;
float _RestDensity;
float _TimeStep = 2;
float _BoundDamping = 0.2;
float3 _BoxSize;



struct MeshObject
{
    float4x4 localToWorld;
    int indicesOffset;
    int indicesCount;
    float3 position;
    float3 AABBMin;
    float3 AABBMax;
    float3 color;
    float emission;
    float smoothness;
    float transparency;
    float absorbtion;
    float celShaded;
    uint id;
};

struct Vertex
{
    float3 position;
    float3 normal;
    float2 uv;
};

struct Ray
{
    float3 o;
    float3 d;
    float3 color;
    float3 energy;
    int bounces;
};

struct Hit
{
    float3 position;
    float distance;
    float3 normal;
    float3 color;
    float2 uv;
    float depth;
    Vertex vertices[3];
    MeshObject meshObj;
};

struct Particle
{
    float3 position;
    float3 force;
    float3 velocity;
    float density;
    float mass;
    float pressure;
};

struct BVHNode
{
    float3 aabbMin;
    float3 aabbMax;
    int leftChild;
    int rightChild;
    int parent;
    int primitiveOffset;
    int primitiveCount;
    int index;
};

StructuredBuffer<MeshObject> _MeshObjects;
StructuredBuffer<Vertex> _Vertices;
StructuredBuffer<int> _Indices;
RWStructuredBuffer<Particle> _Particles;
StructuredBuffer<BVHNode> _BVHNodes;
StructuredBuffer<int> _ParticleIDs;
uint numOfStructs, sizeOfStrides, numOfParticles, sizeOfParticlesStrides;
float density = 0.0;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> DensityMap;
RWTexture2D<float4> NormalMap;

Vertex CreateVertex(inout Vertex v)
{
    v.position = float3(0, 0, 0);
    v.normal = float3(0, 0, 0);
    v.uv = float2(0, 0);
    return v;
}


Ray CreateRay(float3 og, float3 dir, float2 pixel)
{
    Ray ray;
    ray.o = og;
    ray.d = dir;
    ray.color = float3(1, 1, 1);
    ray.energy = float3(0, 0, 0);
    ray.bounces = 0;
    return ray;
}

Hit CreateHit()
{
    Hit hit;
    hit.normal = 0;
    hit.position = 0;
    hit.distance = 1500;
    hit.color = float3(0, 0, 0);
    hit.depth = 0;

    Vertex v0, v1, v2;
    CreateVertex(v0);
    CreateVertex(v1);
    CreateVertex(v2);
    hit.vertices[0] = v0;
    hit.vertices[1] = v1;
    hit.vertices[2] = v2;

    hit.uv = 0;
    hit.meshObj = _MeshObjects[0];
    
    return hit;
}


float4x4 translate(float3 p)
{
    return float4x4 (1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        p.x, p.y, p.z, 1.0);
}

float Poly6Kernel(float distance)
{
	float h = 1.0f - distance / (_Radius* _Radius);
    //return the poly6
	return 315.0f / (64.0f * UNITY_PI * pow(_Radius, 3.0f)) * pow(h, 3.0f);
}

float SpikyKernelD1(float distance)
{
	float h = 1.0f - distance / _Radius;
	//return the spiky
	return -45.0f / (UNITY_PI * pow(_Radius, 4.0f)) * pow(h, 2.0f);
}

float SpikyKernelD2(float distance)
{
	float h = 1.0f - distance / _Radius;
    return 90.0f / (UNITY_PI * pow(_Radius, 5.0f)) * h;
}

float3 SpikyKernelGradient(float distance, float3 direction)
{
	return SpikyKernelD1(distance) * direction;
}

Ray CreateCameraRay(float2 uv)
{
	//Get the world position of the origin, which is basically just the camera.
	// Last column contains position, take that.
    float3 og = mul(_CameraInverseProjection, float4(uv, -1, 1)).xyz;
    og = mul(_CameraToWorld, float4(og, 1)).xyz;

	//The scene has a depth to it. The project matrix takes the depth and places it flat onto a 2D plane.
	//The inverse projection does this process backwards. By multiplying it we go backwards.
    float3 dir = float3(0,0,0);
    dir = worldSpaceViewForward;
    if (_IsOrthographic)
        dir = worldSpaceViewForward;
    else
    {
        dir = mul(_CameraInverseProjection, float4(uv, -1, 1)).xyz;
        dir = mul(_CameraToWorld, float4(dir, 0)).xyz; //Take this 3D pixel point and make it world position.
    }
    

    dir = normalize(dir);
    return CreateRay(og, dir, uv);
}

//Moller method.
bool TriangleTrace(Ray ray, float3 a, float3 b, float3 c, inout float t, inout float u, inout float v)
{
    float3 edge1 = b - a;
    float3 edge2 = c - a;

    float3 pvec = cross(ray.d, edge2);

    float determinate = dot(edge1, pvec);

    if (determinate < epsilon)
        return false;

    float3 tvec = ray.o - a;
    float inv_det = 1.0 / determinate;

    u = dot(tvec, pvec) * inv_det;
    if (u < 0.0 || u > 1.0)
    {
        return false;
    }

    float3 qvec = cross(tvec, edge1);
    v = dot(ray.d, qvec) * inv_det;
    if (v < 0.0 || u + v > 1.0)
    {
        return false;
    }

    //Final calculate of T after crammer's rule.
    t = dot(edge2, qvec) * inv_det;

    return true;
}


//Ray slabs test for AABB.
bool TraceAABB(inout Ray ray, inout Hit hit, MeshObject meshObject)
{
    float3 invRayDir = 1.0 / ray.d;
    float3 tLower = (meshObject.AABBMin - ray.o) * invRayDir;
    float3 tUpper = (meshObject.AABBMax - ray.o) * invRayDir;

    float4 tMin = float4(min(tLower, tUpper), 0);
    float4 tMax = float4(max(tLower, tUpper), 10000000);

    //get max component of tMin.
    float tBoxMin = max(max(tMin.x, tMin.y), tMin.z);
    //get min component of tMax.
    float tBoxMax = min(min(tMax.x, tMax.y), tMax.z);

	return (tBoxMin <= tBoxMax) && (tBoxMax < 99999) && (tBoxMin > epsilon);
}

bool TraceBVH(inout Ray ray, inout Hit hit, BVHNode node)
{
    float3 invRayDir = 1.0 / ray.d;
    float3 tLower = (node.aabbMin - ray.o) * invRayDir;
    float3 tUpper = (node.aabbMax - ray.o) * invRayDir;

    float4 tMin = float4(min(tLower, tUpper), 0);
    float4 tMax = float4(max(tLower, tUpper), 10000000);

    //get max component of tMin.
    float tBoxMin = max(max(tMin.x, tMin.y), tMin.z);
    //get min component of tMax.
    float tBoxMax = min(min(tMax.x, tMax.y), tMax.z);

    return (tBoxMin <= tBoxMax);
}

bool TraceMesh(inout Ray ray, inout Hit hit, MeshObject meshObject)
{
    uint offset = meshObject.indicesOffset;
    uint count = offset + meshObject.indicesCount;
    float3 tuv = 0;

    for (uint i = offset; i < count; i += 3)
    {
        float3 vp0 = (mul(meshObject.localToWorld, float4(_Vertices[_Indices[i]].position, 1))).xyz;
        float3 vp1 = (mul(meshObject.localToWorld, float4(_Vertices[_Indices[i + 1]].position, 1))).xyz;
        float3 vp2 = (mul(meshObject.localToWorld, float4(_Vertices[_Indices[i + 2]].position, 1))).xyz;

        if (TriangleTrace(ray, vp0, vp1, vp2, tuv.x, tuv.y, tuv.z))
        {
            float t = tuv.x;
            if (t > 0 && t < hit.distance)
            {
                //float3 PointPosition = (mul(meshObject.localToWorld, float4(ray.o + t * ray.d, 1))).xyz;
                //Set the vertices
                hit.vertices[0] = _Vertices[_Indices[i]];
                hit.vertices[1] = _Vertices[_Indices[i + 1]];
                hit.vertices[2] = _Vertices[_Indices[i + 2]];
                hit.distance = t;
                hit.uv = float2(tuv.y, tuv.z);
                hit.position = ray.o + t * ray.d;
                hit.meshObj = meshObject;
                return true;
            }
        }
    }
    return false;
}

//Gets how many particles are in this ray, from main directional light to last particle.
float GetDensityOfParticle(in Hit hit, in Ray ray)
{
    int particleDensity = 0; //This will be the density later on.
    float squaredDepthOfParticle = sqrt(numOfParticles)*25;

    for (int i = 0; i < numOfParticles; i++)
    {
        //Shoot ray to the direction of the light.
        float3 rayOrig = hit.position; //Start from the hit position, then shoot towards light.
        float3 rayDir = normalize(_LightSource - rayOrig);
		float3 center = _Particles[i].position;
        
        rayDir = normalize(_LightSource - rayOrig);
        //center = mul(_ParentTransform, float4(center, 1)).xyz;
        
        float t1 = sphIntersect(rayOrig, rayDir, float4(center, 0.5));
        
        //If it hit a particle add that to the total number of particles to obtain density.
        if (t1 > epsilon)
        {
            //New point is now the nearest particle.
            rayOrig = rayOrig + rayDir * (t1 + epsilon * 100);

            particleDensity++;
        }
    }

    //Now we do an attenuation, which is the y/x^2.
    return 2.55* particleDensity / (squaredDepthOfParticle);
    
}

//Intersects particles with the ray being casted. Used to render particles.
float IntersectParticles(inout Hit hit, in Ray ray, float radius, float3 center)
{
	float3 rayOrig = ray.o;
	float3 rayDir = ray.d;
	//center = mul(_ParentTransform, float4(center, 1)).xyz;

    //Get box transformation matrix.
	float4x4 tra = translate(center);
    float4x4 txi = tra;
    float4x4 txx = inverse2(txi);
    float t1 = 0;
	float3 rad = float3(radius, radius, radius);
    
    //Intersect with a box and then smoothly combine boxes together with union operation.
    float4 tNFnorm = boxIntersection2(rayOrig, rayDir, txx, txi, rad);//sphIntersect(rayOrig, rayDir, float4(center, rad.x));//boxIntersection2(rayOrig, rayDir, txx, txi, rad);
	t1 = tNFnorm.x;
    t1 = opU(t1, hit.distance);
    
    /*
    //If it hit a box give it the detail to render this particle.
	if (t1 > epsilon && t1 < hit.distance)
    {
        hit.position = rayOrig + t1 * ray.d;
        
        //Calculate the depth by dividing the perspective of the camera.
        float4 clipPos = UnityWorldToClipPos(hit.position);
        float depth = (clipPos.z* _DepthScale.x) / (clipPos.w * _DepthScale.y);
        hit.depth = 1.0 - depth;
        if(_IsOrthographic)
		{
            hit.depth *= 100;
		}

		//Calculate the normal of a supposed sphere, this isn't the normal of the particle that is a seperate buffer.
        float3 n = GetSphereNormal(hit.position, radius);
        hit.normal = n;
        hit.distance = t1;
        hit.color = 1;

        density = GetDensityOfParticle(hit, ray);
        
        return hit;
    }
    */
    return t1;
}

int nextNode(in BVHNode node, in Ray ray, in Hit hit, int nodeIndex)
{
    if(node.leftChild != -1)
	{
		return node.leftChild;
	}
    if (node.rightChild != -1)
    {
        return node.rightChild;
    }

    while (node.parent > -1)
    {
        //If I am the left child, and my parent has right child...go to the right child.
        if (node.index == _BVHNodes[node.parent].leftChild && _BVHNodes[node.parent].rightChild != -1)
        {
            return _BVHNodes[node.parent].rightChild;
        }
        node = _BVHNodes[node.parent];
    }

    return -1;
}

float4 SceneTrace(inout Ray ray, inout Hit hit)
{
    float minDistance = 99999999;
    /*
    for (int k = 0; k < numOfStructs; k++)
    {
        MeshObject meshObject = _MeshObjects[k];
        if (TraceAABB(ray, hit, meshObject) == true)
        {
            TraceMesh(ray, hit, meshObject);
        }

    }
    */

    //If a particle is in front perform the calculation. This will overwrite the information about meshes in the scene.
    int nodeIndex = 0;
    int currentNode = 0;
    BVHNode node = _BVHNodes[currentNode];
	bool particleHit = false;
    while (particleHit == false)
    {
        /*
        if (!TraceBVH(ray, hit, node))
        {
            particleHit = true;
            break;
        }
        */
        if (node.primitiveCount > 0)
        {
            for (int k = node.primitiveOffset; k < node.primitiveCount; k++)
            {
                float3 position = _Particles[_ParticleIDs[k]].position;

                float t1 = IntersectParticles(hit, ray, _SizeOfParticle, position);

                if (t1 > epsilon && t1 < minDistance)
                {
                    minDistance = t1;
                }
            }
            //particleHit = true;

        }
        /*

        int nextNode = -1;

        if (!TraceBVH(ray, hit, _BVHNodes[node.leftChild]))
        {
            _BVHNodes[node.leftChild].visited = 2;
        }

        if (!TraceBVH(ray, hit, _BVHNodes[node.leftChild + 1]))
        {
            _BVHNodes[node.leftChild + 1].visited = 2;
        }

        if (node.visited == 0)
        {
            nextNode = node.leftChild;
            node.visited++;
        }

        if (node.visited == 1)
        {
            nextNode = node.leftChild + 1;
            node.visited++;
        }

        if (node.visited == 2 || node.primitiveCount > 0)
        {
            nextNode = node.parent;
        }
        */
        /*
        if(TraceBVH(ray, hit, _BVHNodes[node.leftChild]))
		{
            currentNode = node.leftChild;
		}
		else if (TraceBVH(ray, hit, _BVHNodes[node.rightChild]))
		{
            currentNode = node.rightChild;
		}
        else
        {
            break;
        }
        */
        nodeIndex++;
        currentNode = nextNode(node,ray, hit, currentNode);//_BVHNodes[nextNode];
        node = _BVHNodes[currentNode];
        //node = _BVHNodes[nodeIndex];


        if (nodeIndex >= numOfParticles || currentNode == -1)
        {
            particleHit = true;
            break;
        }
    }
    /*
    for (int k = 0; k < numOfParticles; k++)
    {
        float3 position = _Particles[k].position;

        float t1 = IntersectParticles(hit, ray, _SizeOfParticle, position);

        if (t1 > epsilon && t1 < minDistance)
        {
            minDistance = t1;
        }
    }
    */
    /*
    MeshObject meshObject = hit.meshObj;
    Vertex v0 = hit.vertices[0];
    Vertex v1 = hit.vertices[1];
    Vertex v2 = hit.vertices[2];
    //Convert to world space along with ray and compute the barycentric coordinate.
    v0.position = (mul(meshObject.localToWorld, float4(v0.position, 1))).xyz;
    v1.position = (mul(meshObject.localToWorld, float4(v1.position, 1))).xyz;
    v2.position = (mul(meshObject.localToWorld, float4(v2.position, 1))).xyz;
    v0.normal = (mul(meshObject.localToWorld, float4(v0.normal, 0))).xyz;
    v1.normal = (mul(meshObject.localToWorld, float4(v1.normal, 0))).xyz;
    v2.normal = (mul(meshObject.localToWorld, float4(v2.normal, 0))).xyz;
    float3 barycentric = Barycentric(v0.position, v1.position, v2.position, hit.position);

    //Now that we have the barycentric coordinate we can use this to reconstruct the UVs.
    float2 uvs = v0.uv * barycentric.x + v1.uv * barycentric.y + v2.uv * barycentric.z;

    float3 normals = normalize(v0.normal * barycentric.x + v1.normal * barycentric.y + v2.normal * barycentric.z);

    hit.normal = normals;
    hit.uv = uvs;
    */
	float3 position = ray.o + minDistance * ray.d;
    float4 clipPos = UnityWorldToClipPos(position);
    float depth = (clipPos.z * _DepthScale.x) / (clipPos.w * _DepthScale.y);
    depth = 1.0 - depth;
    depth *= minDistance < 99999;
	return float4(position, depth);
    
}

void CollisionTrace(inout Ray ray, inout Hit hit)
{
    for (int k = 0; k < numOfStructs; k++)
    {
        MeshObject meshObject = _MeshObjects[k];
        if (TraceAABB(ray, hit, meshObject) == true)
        {
            TraceMesh(ray, hit, meshObject);
        }

    }
}

[numthreads(32,32,1)]
void CreateGrid (uint3 id : SV_DispatchThreadID)
{
    //Create grid of spheres in 3D.
    
    density = 0;
    uint width, height;
    worldSpaceViewForward = -UNITY_MATRIX_I_V._m02_m12_m22;
    _MeshObjects.GetDimensions(numOfStructs, sizeOfStrides);
	_Particles.GetDimensions(numOfParticles, sizeOfParticlesStrides);
    Result.GetDimensions(width, height);


	//This is a ray for each pixel and in the pixel's center.
	//So id.xy is this pixel, then offsetted to center, then divided by the width and height to get said center.
	//Then range is shifted via 2 - 1.
    float2 pixel = ((id.xy + float2(0.5, 0.5)) / float2(width, height)) * 2 - 1; //Note in HLSL this vector v - scalar is applied to each element in v.
    Ray ray = CreateCameraRay(pixel);
    Hit hit = CreateHit();

    float4 particle = SceneTrace(ray, hit);
    Result[id.xy] = float4(particle.xyz * 0.015, particle.w);
	DensityMap[id.xy] = density;
}

//Based on the following paper: https://matthias-research.github.io/pages/publications/sca03.pdf
// Particle-Based Fluid Simulation for Interactive Applications
[numthreads(100, 1, 1)]
void UpdateParticles(uint3 id : SV_DispatchThreadID)
{
    _MeshObjects.GetDimensions(numOfStructs, sizeOfStrides);
    _Particles.GetDimensions(numOfParticles, sizeOfParticlesStrides);
    _TimeStep = 0.02;
    float boundsDamping = -0.3;
    _Particles[id.x].force = float3(0, -9.8, 0);
    // Compute the new velocity via the current force by the mass via f = ma. Then integrate the velocity via v = v + at.

	float3 vel = _Particles[id.x].velocity + (_Particles[id.x].force/ 1) * _TimeStep;

    //center = mul(_ParentTransform, float4(center, 1)).xyz;
	float3 previousPoint = _Particles[id.x].position;
	float3 nextPoint = previousPoint + vel * _TimeStep;

	//float3 wpreviousPoint = mul(_ParentTransform, float4(previousPoint, 1)).xyz;
	//float3 wnextPoint = mul(_ParentTransform, float4(nextPoint, 1)).xyz;

    float2 pixel = ((id.xy + float2(0.5, 0.5)) / float2(1, 1)) * 2 - 1; //Note in HLSL this vector v - scalar is applied to each element in v.
    Ray ray = CreateCameraRay(pixel);
    Hit hit = CreateHit();
    /*
	ray.o = previousPoint;
	ray.d = normalize(nextPoint - previousPoint);

    CollisionTrace(ray, hit);
    
	if (hit.distance < abs(length(nextPoint - previousPoint)))
	{
		//We hit something.
		_Particles[id.x].position = hit.position;
        
	}
    else
    {

        _Particles[id.x].position = nextPoint;
    }
    //Handle collisions.
    */
    
    /*
    ray.o = previousPoint;
    ray.d = normalize(float3(0, -1, 0));

    CollisionTrace(ray, hit);

    if (hit.distance < 0.525)
    {
        //We hit something.
        //_Particles[id.x].position = hit.position;

    }
    else
    {

        _Particles[id.x].position = nextPoint;
    }
    */
    float3 boxSize = _BoxSize;//mul(_ParentTransform, float4(_BoxSize, 1)).xyz;
    float3 topRight = boxSize/2;
	float3 bottomLeft = -boxSize/2;
	//bottomLeft = mul(_ParentTransform, float4(bottomLeft, 1)).xyz;
	//topRight = mul(_ParentTransform, float4(topRight, 1)).xyz;
    //Min Boundary Enforcements
	_Particles[id.x].position = nextPoint;

	if (_Particles[id.x].position.x - _Radius < bottomLeft.x)
	{
		vel.x *= boundsDamping;
		_Particles[id.x].position.x = bottomLeft.x + _Radius;
	}
	if (_Particles[id.x].position.y - _Radius < bottomLeft.y)
	{
		vel.y *= boundsDamping;
		_Particles[id.x].position.y = bottomLeft.y + _Radius;
	}
	if (_Particles[id.x].position.z - _Radius < bottomLeft.z)
	{
		vel.z *= boundsDamping;
		_Particles[id.x].position.z = bottomLeft.z + _Radius;
	}


    //Max Boundary Enforcements
	if (_Particles[id.x].position.x + _Radius > topRight.x)
	{
		vel.x *= boundsDamping;
		_Particles[id.x].position.x = topRight.x - _Radius;
	}
	if (_Particles[id.x].position.y + _Radius > topRight.y)
	{
		vel.y *= boundsDamping;
		_Particles[id.x].position.y = topRight.y - _Radius;
	}
	if (_Particles[id.x].position.z + _Radius > topRight.z)
	{
		vel.z *= boundsDamping;
		_Particles[id.x].position.z = topRight.z - _Radius;
	}
    
    _Particles[id.x].velocity = vel;

}

//Figure (1)
[numthreads(64, 1, 1)]
void ComputeDensity(uint3 id : SV_DispatchThreadID)
{
    _Particles.GetDimensions(numOfParticles, sizeOfParticlesStrides);

    //Loop through all particles comparing it to current particle.
    float3 oPos = _Particles[id.x].position;
    float sum = 0;

    //Check if that particle is in the radius.
    for (int i = 0; i < numOfParticles; i++)
    {
        float distance = dot(_Particles[i].position - oPos, _Particles[i].position - oPos);
        if (distance < 0.000001)
        {
            continue;
        }
        if (distance * 0.004 > _Radius*_Radius * 0.004)
        {
            sum += Poly6Kernel(distance*0.004);
        }
    }

    _Particles[id.x].density = sum * _Particles[id.x].mass * 0.000001;
    _Particles[id.x].pressure = _GasConstant * (_Particles[id.x].density - _RestDensity);
}

[numthreads(64, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    _Particles.GetDimensions(numOfParticles, sizeOfParticlesStrides);
    float3 origin = _Particles[id.x].position;
    float density = _Particles[id.x].density * _Particles[id.x].density;
	float mass = _Particles[id.x].mass * _Particles[id.x].mass;
	float3 pressure = float3(0, 0, 0);
	float3 visc = float3(0, 0, 0);
    float viscosity = -0.006;

    for (int i = 0; i < numOfParticles; i++)
    {
        float dist = distance(_Particles[i].position, origin);
        if (dist < 0.000001)
        {
            continue;
        }
        
        if (dist < _Radius * 2)
        {
			float3 pressureGradDir = normalize(origin - _Particles[i].position);
            float3 pressureContrib = mass * SpikyKernelGradient(dist, pressureGradDir);
			pressureContrib *= (_Particles[id.x].pressure / density + _Particles[i].pressure / (_Particles[i].density * _Particles[i].density));

            float3 viscosityContrib = viscosity * mass * (_Particles[i].velocity - _Particles[id.x].velocity) / _Particles[i].density * SpikyKernelD2(dist);
            
			pressure += pressureContrib;
			visc += viscosityContrib;
            
        }
    }
    
    _Particles[id.x].force = float3(0, -9.81 * _Particles[id.x].mass, 0) - pressure + visc;
}


[numthreads(64, 1, 1)]
void SpacePartition(uint3 id : SV_DispatchThreadID)
{
    _Particles.GetDimensions(numOfParticles, sizeOfParticlesStrides);
}