// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RayTrace
#include "../ShaderHelpers.hlsl"

RWTexture2D<float4> _RayTracer;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
Texture2D<float4> _SkyBoxTexture;
SamplerState sampler_SkyBoxTexture;
float epsilon = 0.001;
struct Ray
{
	float3 o;
	float3 d;
	float2 os; //pixel screen space.
	float3 energy;
};

struct Hit
{
	float3 position;
	float distance;
	float3 normal;
	float3 color;
};

Ray CreateRay(float3 og, float3 dir, float2 pixel)
{
	Ray ray;
	ray.o = og;
	ray.d = dir;
	ray.os = pixel;
	ray.energy = float3(1, 1, 1);
	return ray;
}

Ray CreateCameraRay(float2 uv)
{
	//Get the world position of the origin, which is basically just the camera.
	// Last column contains position, take that.
	float3 og = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;

	//The scene has a depth to it. The project matrix takes the depth and places it flat onto a 2D plane.
	//The inverse projection does this process backwards. By multiplying it we go backwards.
	float3 dir = mul(_CameraInverseProjection, float4(uv, -1, 1)).xyz;
	dir = mul(_CameraToWorld, float4(dir, 0)).xyz; //Take this 3D pixel point and make it world position.
	dir = normalize(dir);
	return CreateRay(og, dir, uv);
}

float4 SampleSkyBox(in Ray ray)
{
	float3 dir = normalize(ray.d);
	float u = 0.5 + atan2(dir.z, dir.x) / (2 * UNITY_PI);
	float v = 0.5 - asin(dir.y) / UNITY_PI;
	return _SkyBoxTexture.SampleLevel(sampler_SkyBoxTexture, float2(u, v), 0);
	
	
}

Hit Shade(inout Hit hit, Ray ray, float3 normal)
{
	float3 lightDir = normalize(_WorldSpaceLightPos0);
	float NdotL = clamp(dot(normal, lightDir), 0.0825, 1.0);
	hit.color = NdotL * _LightColor0.xyz;
	return hit;
}


Hit IntersectPlane(inout Hit hit, Ray ray, float3 a, float3 b, float3 c)
{

	float3 n = GetTriangleNormal(a, b, c);

	float3 center = GetTriangleCenter(a, b, c);
	float t = dot(center - ray.o, n) / dot(ray.d, n);
	if (t > epsilon && t < hit.distance)
	{
		hit.normal = n;
		hit.distance = t;
		hit.position = ray.o + t * ray.d;
		Shade(hit, ray, n);
		hit.color *= 20/t;
	}
	return hit;
}



Hit IntersectSphere(inout Hit hit, Ray ray, float radius, float3 center)
{
	//Quadratic formula.
	float a = dot(ray.d, ray.d);
	float b = 2 * dot((ray.o - center), ray.d);
	float c = dot(ray.o - center, ray.o - center) - radius * radius;
	float d = b * b - 4 * a * c;

	float t1 = (-b + sqrt(b * b - 4 * a * c) / 2 * a);
	float t2 = (-b - sqrt(b * b - 4 * a * c) / 2 * a);

	if(d < 0)
		return hit;
	if (t1 > epsilon && t1 < hit.distance && t1 < t2)
	{
		hit.position = ray.o + t1 * ray.d;

		float3 n = GetSphereNormal(hit.position, radius);
		hit.normal = n;
		hit.distance = t1;
		Shade(hit, ray, n);
		return hit;
	}
	else if (t2 > epsilon && t2 < hit.distance && t2 < t1)
	{
		hit.position = ray.o + t2 * ray.d;
		float3 n = GetSphereNormal(hit.position, radius);
		hit.normal = n;
		hit.distance = t2;
		Shade(hit, ray, n);
	}
	return hit;
}


[numthreads(32,32,1)]
void RayTrace(uint3 id : SV_DispatchThreadID)
{
	uint width, height;
	_RayTracer.GetDimensions(width, height);
	
	//This is a ray for each pixel and in the pixel's center.
	//So id.xy is this pixel, then offsetted to center, then divided by the width and height to get said center.
	//Then range is shifted via 2 - 1.
	float2 pixel = ((id.xy + float2(0.5, 0.5)) / float2(width, height)) * 2 - 1; //Note in HLSL this vector v - scalar is applied to each element in v.

	Ray ray = CreateCameraRay(pixel);
	// Write some colors
	//_RayTracer[id.xy] = float4(ray.direction * 0.5f + 0.5f, 1.0f);
	//Create a plane.
	float3 a = float3(1, -10, 0);
	float3 b = float3(-1, -10, 0);
	float3 c = float3(0.5, -10, 0.5);

	Hit hit;
	hit.color = 0;
	hit.normal = 0;
	hit.position = 0;
	hit.distance = 99999999;
	
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			float3 center = float3(i, 0, j);
			IntersectSphere(hit, ray, 0.5, center);
		}
	}
	//IntersectSphere(hit, ray, 4, float3(0, 2, 0));
	IntersectPlane(hit, ray, a, b, c);


	_RayTracer[id.xy] = SampleSkyBox(ray);//float4(hit.color, 1);


}

