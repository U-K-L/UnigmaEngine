// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CreateGrid
#include "../../ShaderHelpers.hlsl"
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 _ParentTransform;
float4x4 _CameraWorldToLocal;
float4x4 _ParentTransformToLocal;

float epsilon = 0.00001;
float _Smoothness;
float4 _DepthScale = 1;




struct MeshObject
{
    float4x4 localToWorld;
    int indicesOffset;
    int indicesCount;
    float3 position;
    float3 AABBMin;
    float3 AABBMax;
    float3 color;
    float emission;
    float smoothness;
    float transparency;
    float absorbtion;
    float celShaded;
    uint id;
};

struct Vertex
{
    float3 position;
    float3 normal;
    float2 uv;
};

struct Ray
{
    float3 o;
    float3 d;
    float3 color;
    float3 energy;
    int bounces;
};

struct Hit
{
    float3 position;
    float distance;
    float3 normal;
    float3 color;
    float2 uv;
    float depth;
    Vertex vertices[3];
    MeshObject meshObj;
};

StructuredBuffer<MeshObject> _MeshObjects;
StructuredBuffer<Vertex> _Vertices;
StructuredBuffer<int> _Indices;
uint numOfStructs, sizeOfStrides;
float density = 0.0;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> DensityMap;
RWTexture2D<float4> NormalMap;

Vertex CreateVertex(inout Vertex v)
{
    v.position = float3(0, 0, 0);
    v.normal = float3(0, 0, 0);
    v.uv = float2(0, 0);
    return v;
}


Ray CreateRay(float3 og, float3 dir, float2 pixel)
{
    Ray ray;
    ray.o = og;
    ray.d = dir;
    ray.color = float3(1, 1, 1);
    ray.energy = float3(0, 0, 0);
    ray.bounces = 0;
    return ray;
}

Hit CreateHit()
{
    Hit hit;
    hit.normal = 0;
    hit.position = 0;
    hit.distance = 1500;
    hit.color = float3(0, 0, 0);
    hit.depth = 0;

    Vertex v0, v1, v2;
    CreateVertex(v0);
    CreateVertex(v1);
    CreateVertex(v2);
    hit.vertices[0] = v0;
    hit.vertices[1] = v1;
    hit.vertices[2] = v2;

    hit.uv = 0;
    hit.meshObj = _MeshObjects[0];
    
    return hit;
}

Ray CreateCameraRay(float2 uv)
{
	//Get the world position of the origin, which is basically just the camera.
	// Last column contains position, take that.
    float3 og = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;

	//The scene has a depth to it. The project matrix takes the depth and places it flat onto a 2D plane.
	//The inverse projection does this process backwards. By multiplying it we go backwards.
    float3 dir = mul(_CameraInverseProjection, float4(uv, -1, 1)).xyz;
    dir = mul(_CameraToWorld, float4(dir, 0)).xyz; //Take this 3D pixel point and make it world position.
    dir = normalize(dir);
    return CreateRay(og, dir, uv);
}


float opU(float d1, float d2)
{
    return min(d1, d2);
}

float2 sminN(float a, float b, float k, float n)
{
    float h = max(k - abs(a - b), 0.0) / k;
    float m = pow(h, n) * 0.5;
    float s = m * k / n;
    return (a < b) ? float2(a - s, m) : float2(b - s, 1.0 - m);
}

// polynomial smooth min
float smin(float a, float b, float k)
{
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * (1.0 / 4.0);
}


float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return lerp(d2, d1, h) - k * h * (1.0 - h);
}

float3 gsmin(in float4 a, in float4 b, in float k)
{
    float h = max(k - abs(a.x - b.x), 0.0);
    float m = 0.25 * h * h / k;
    float n = 0.50 * h / k;
    return float3(min(a.x, b.x) - m,
        lerp(a.yzw, b.yzw, (a.x < b.x) ? n : 1.0 - n).xy);
}

//Moller method.
bool TriangleTrace(Ray ray, float3 a, float3 b, float3 c, inout float t, inout float u, inout float v)
{
    float3 edge1 = b - a;
    float3 edge2 = c - a;

    float3 pvec = cross(ray.d, edge2);

    float determinate = dot(edge1, pvec);

    if (determinate < epsilon)
        return false;

    float3 tvec = ray.o - a;
    float inv_det = 1.0 / determinate;

    u = dot(tvec, pvec) * inv_det;
    if (u < 0.0 || u > 1.0)
    {
        return false;
    }

    float3 qvec = cross(tvec, edge1);
    v = dot(ray.d, qvec) * inv_det;
    if (v < 0.0 || u + v > 1.0)
    {
        return false;
    }

    //Final calculate of T after crammer's rule.
    t = dot(edge2, qvec) * inv_det;

    return true;
}


//Ray slabs test for AABB.
bool TraceAABB(inout Ray ray, inout Hit hit, MeshObject meshObject)
{
    float3 invRayDir = 1.0 / ray.d;
    float3 tLower = (meshObject.AABBMin - ray.o) * invRayDir;
    float3 tUpper = (meshObject.AABBMax - ray.o) * invRayDir;

    float4 tMin = float4(min(tLower, tUpper), 0);
    float4 tMax = float4(max(tLower, tUpper), 10000000);

    //get max component of tMin.
    float tBoxMin = max(max(tMin.x, tMin.y), tMin.z);
    //get min component of tMax.
    float tBoxMax = min(min(tMax.x, tMax.y), tMax.z);

    return tBoxMin <= tBoxMax;
}

bool TraceMesh(inout Ray ray, inout Hit hit, MeshObject meshObject)
{
    uint offset = meshObject.indicesOffset;
    uint count = offset + meshObject.indicesCount;
    float3 tuv = 0;

    for (uint i = offset; i < count; i += 3)
    {
        float3 vp0 = (mul(meshObject.localToWorld, float4(_Vertices[_Indices[i]].position, 1))).xyz;
        float3 vp1 = (mul(meshObject.localToWorld, float4(_Vertices[_Indices[i + 1]].position, 1))).xyz;
        float3 vp2 = (mul(meshObject.localToWorld, float4(_Vertices[_Indices[i + 2]].position, 1))).xyz;

        if (TriangleTrace(ray, vp0, vp1, vp2, tuv.x, tuv.y, tuv.z))
        {
            float t = tuv.x;
            if (t > 0 && t < hit.distance)
            {
                //float3 PointPosition = (mul(meshObject.localToWorld, float4(ray.o + t * ray.d, 1))).xyz;
                //Set the vertices
                hit.vertices[0] = _Vertices[_Indices[i]];
                hit.vertices[1] = _Vertices[_Indices[i + 1]];
                hit.vertices[2] = _Vertices[_Indices[i + 2]];
                hit.distance = t;
                hit.uv = float2(tuv.y, tuv.z);
                hit.position = ray.o + t * ray.d;
                hit.meshObj = meshObject;
                return true;
            }
        }
    }
    return false;
}

//Gets how many particles are in this ray, from camera to last particle.
float GetDensityOfParticle(in Hit hit, in Ray ray)
{
    float numOfParticles = 0.0;
    int nSpheres = 10;
    float3 rayOrig = ray.o;
    float3 rayDir = ray.d;
    for (int i = 0; i < nSpheres; i++)
    {
        for (int j = 0; j < nSpheres; j++)
        {
            for (int k = 0; k < nSpheres; k++)
            {
                float3 center = float3(i, j, k);
                center = mul(_ParentTransform, float4(center, 1)).xyz;
                float t1 = sphIntersect(rayOrig, rayDir, float4(center, 0.25));
                if (t1 > -0.9)
                {
                    rayOrig = rayOrig + rayDir * (t1 + epsilon*100);
                    numOfParticles++;
                }
                
            }

        }

    }
    return numOfParticles / (nSpheres* nSpheres);
    
}


float4x4 translate(float3 p)
{
    return float4x4 (1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        p.x, p.y, p.z, 1.0);
}

Hit IntersectSphere(inout Hit hit, in Ray ray, float radius, float3 center)
{
	float3 rayOrig = ray.o;
	float3 rayDir = ray.d;
	center = mul(_ParentTransform, float4(center, 1)).xyz;

	float4x4 tra = translate(center);
    float4x4 txi = tra;
    float4x4 txx = inverse2(txi);
    //float t1 = sphIntersect(rayOrig, rayDir, float4(center, radius));

    //float t1 = tNFnorm.x;//opSmoothUnion(tNFnorm.x, hit.distance, _Smoothness);//opU(t1, hit.distance);
    float t1 = 0;
    float t2 = 0;
	float3 rad = float3(radius, radius, radius);
    //IntersectBox(rayOrig, rayDir, center, center + rad, t2, t1)
    float4 tNFnorm = boxIntersection2(rayOrig, rayDir, txx, txi, rad);
	t1 = tNFnorm.x;
	if (t1 > epsilon && t1 < hit.distance)
    {
       
        hit.position = rayOrig + t1 * ray.d;//gsmin(float4(rayOrig + t1 * ray.d, 0.25), float4(rayOrig + t1 * ray.d, 0.25), _Smoothness);//rayOrig + t1 * ray.d;
        float4 clipPos = UnityWorldToClipPos(hit.position);
        float depth = (clipPos.z* _DepthScale.x) / (clipPos.w * _DepthScale.y);
        hit.depth = 1.0 - depth;
        float3 n = GetSphereNormal(hit.position, radius);
        hit.normal = n;
        hit.distance = t1;
        hit.color = 1;

        //density = GetDensityOfParticle(hit, ray);
        
        return hit;
    }
    //Convert ray from worldspace to object's local space.
    /*
	rayOrig = mul(_CameraWorldToLocal, float4(rayOrig, 1)).xyz;
	rayDir = mul(_CameraWorldToLocal, float4(rayDir, 0)).xyz;
	center = mul(_CameraWorldToLocal, float4(center, 1)).xyz;
    */
	//rayOrig = mul(_ParentTransformToLocal, float4(rayOrig, 1)).xyz;
	//rayDir = mul(_ParentTransformToLocal, float4(rayDir, 0)).xyz;
    
    
	//Quadratic formula.
    //Move center by world matrix.
    //center = mul(_ParentTransform, float4(center, 1)).xyz;
	//center = mul(_CameraWorldToLocal, float4(center, 1)).xyz;
	//center = mul(_ParentTransformToLocal, float4(center, 1)).xyz;
    //Scale radius by scale.
    //radius *= _ParentTransform._m00;
    //float3 rayOrig = mul(_ParentTransformToLocal, float4(ray.o, 1)).xyz;//ray.o;//mul(_CameraWorldToLocal, float4(ray.o, 1)).xyz;
    //rayOrig = mul(_CameraWorldToLocal, float4(ray.o, 1)).xyz;
    //rayOrig = mul(_ParentTransformToLocal, float4(ray.o, 1)).xyz;
    //rayOrig += center;
    //float3 rayDir = mul(_ParentTransformToLocal, float4(ray.d, 1)).xyz;//ray.d;//mul(_CameraWorldToLocal, float4(ray.d, 1)).xyz;
	//rayDir = mul(_CameraWorldToLocal, float4(ray.d, 1)).xyz;
	//rayDir = mul(_ParentTransformToLocal, float4(ray.d, 1)).xyz;

    /*
    float a = dot(rayDir, rayDir);
    float b = 2 * dot((rayOrig - center), rayDir);
    float c = dot(rayOrig - center, rayOrig - center) - radius * radius;
    float d = b * b - 4 * a * c;

    float t1 = (-b + sqrt(b * b - 4 * a * c) / 2 * a);
    float t2 = (-b - sqrt(b * b - 4 * a * c) / 2 * a);

    
    if (d < 0)
        return hit;
    if (t1 > epsilon && t1 < hit.distance && t1 < t2)
    {
        hit.position = rayOrig + t1 * ray.d;
        hit.position = mul(_ParentTransform, float4(hit.position, 1)).xyz;
        hit.position = mul(_CameraToWorld, float4(hit.position, 1)).xyz;
        float4 clipPos = UnityWorldToClipPos(hit.position);
        float depth = clipPos.z / clipPos.w;
        hit.depth = 1.0 - depth;
        float3 n = GetSphereNormal(hit.position, radius);
        hit.normal = n;
        hit.distance = t1;
        hit.color = 1;
        
        return hit;
    }
    else if (t2 > epsilon && t2 < hit.distance && t2 < t1)
    {
        hit.position = rayOrig + t2 * ray.d;
        hit.position = mul(_ParentTransform, float4(hit.position, 1)).xyz;
        hit.position = mul(_CameraToWorld, float4(hit.position, 1)).xyz;
        float4 clipPos = UnityWorldToClipPos(hit.position);
        float depth = clipPos.z / clipPos.w;
        hit.depth = 1.0 - depth;
        float3 n = GetSphereNormal(hit.position, radius);
        hit.normal = n;
        hit.distance = t2;
        hit.color = 1;

        return hit;
    }
    */
    return hit;
}

void SceneTrace(inout Ray ray, inout Hit hit)
{
    for (int k = 0; k < numOfStructs; k++)
    {
        MeshObject meshObject = _MeshObjects[k];
        if (TraceAABB(ray, hit, meshObject) == true)
        {
            TraceMesh(ray, hit, meshObject);
        }

    }
    int nSpheres = 10;
    for (int i = 0; i < nSpheres; i++)
    {
        for (int j = 0; j < nSpheres; j++)
        {
            for (int k = 0; k < nSpheres; k++)
            {
                float3 position = float3(i, j, k);

                IntersectSphere(hit, ray, 0.125, position);
            }

        }

    }
    MeshObject meshObject = hit.meshObj;
    Vertex v0 = hit.vertices[0];
    Vertex v1 = hit.vertices[1];
    Vertex v2 = hit.vertices[2];
    //Convert to world space along with ray and compute the barycentric coordinate.
    v0.position = (mul(meshObject.localToWorld, float4(v0.position, 1))).xyz;
    v1.position = (mul(meshObject.localToWorld, float4(v1.position, 1))).xyz;
    v2.position = (mul(meshObject.localToWorld, float4(v2.position, 1))).xyz;
    v0.normal = (mul(meshObject.localToWorld, float4(v0.normal, 0))).xyz;
    v1.normal = (mul(meshObject.localToWorld, float4(v1.normal, 0))).xyz;
    v2.normal = (mul(meshObject.localToWorld, float4(v2.normal, 0))).xyz;
    float3 barycentric = Barycentric(v0.position, v1.position, v2.position, hit.position);

    //Now that we have the barycentric coordinate we can use this to reconstruct the UVs.
    float2 uvs = v0.uv * barycentric.x + v1.uv * barycentric.y + v2.uv * barycentric.z;

    float3 normals = normalize(v0.normal * barycentric.x + v1.normal * barycentric.y + v2.normal * barycentric.z);

    hit.normal = normals;
    hit.uv = uvs;

}

/*
void SceneTrace(inout Ray ray, inout Hit hit)
{
    /*
    int nSpheres = 30;
    for (int i = 0; i < nSpheres; i++)
    {
        for (int j = 0; j < nSpheres; j++)
        {
            for (int k = 0; k < nSpheres; k++)
            {
                float3 position = float3(i, j, k);
                float3 worldPos = mul(_CameraToWorld, float4(position, 1)).xyz;
                
                //IntersectSphere(hit, ray, 1, position);
				IntersectSphere2(hit, ray, float4(worldPos, 1));
            }

        }

    }
    //float3 center = mul(_ParentTransform, float4(1,1,1, 1)).xyz;
    IntersectSphere(hit, ray, 10, float3(0,0,0));
}
*/
[numthreads(8,8,1)]
void CreateGrid (uint3 id : SV_DispatchThreadID)
{
    //Create grid of spheres in 3D.
    
    density = 0;
    uint width, height;
    _MeshObjects.GetDimensions(numOfStructs, sizeOfStrides);
    Result.GetDimensions(width, height);


	//This is a ray for each pixel and in the pixel's center.
	//So id.xy is this pixel, then offsetted to center, then divided by the width and height to get said center.
	//Then range is shifted via 2 - 1.
    float2 pixel = ((id.xy + float2(0.5, 0.5)) / float2(width, height)) * 2 - 1; //Note in HLSL this vector v - scalar is applied to each element in v.
    Ray ray = CreateCameraRay(pixel);
    Hit hit = CreateHit();

    SceneTrace(ray, hit);
    
    float3 camPos = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    
    //WorldPosition, depth.
    hit.position *= 0.015;
    float4 particle = float4(hit.position, hit.depth); //float4(hit.normal, 1);
    Result[id.xy] = particle;
	DensityMap[id.xy] = density;
}
