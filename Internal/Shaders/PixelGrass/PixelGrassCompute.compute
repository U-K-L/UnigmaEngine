//This is an example of compute shaders and acts as an active reference.

//A kernal is a function to be dispatched. This is the function that will run upon starting the compute shader.
#pragma kernel Main

//In here we can include hlsl
//#include file.hlsl

#include "../ShaderHelpers.hlsl"

//Let's define our vertexs. We will make this a struct.

//The vertices of the source mesh given by C#.
struct SourceVertex {
	float3 position; //This is in object space.
};

//output vertices to send back to C#.

struct OutputVertex
{
	float3 position;
	float3 normal;
	float2 uv;
};

//The triangles to output.

struct OutputTriangle
{
	float3 normal; //This normal in world space.
	OutputVertex vertices[6];
};

//This is the args buffer.
struct IndirectArgs {
	uint numVerticesPerInstance;
	uint numInstances;
	uint startVertexLocation;
	uint startInstanceLocation;
};

//Declare the variables needed. An array that is read only.
StructuredBuffer <SourceVertex> _sourceVertices;
StructuredBuffer <int> _sourceTriangles;
RWStructuredBuffer<OutputVertex> _outputVertices;
AppendStructuredBuffer <OutputTriangle> _outputTriangles; //This acts as a stack.

RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;

//These are the variables that are set by C#.
int _NumOfTriangles;
float _Width, _Height;
float4x4 _LocalToWorldMatrix;

OutputVertex CreateVertex(SourceVertex v)
{
	OutputVertex vertex;
	vertex.position = mul(_LocalToWorldMatrix, float4(v.position, 1.0f)).xyz;
	return vertex;
}

OutputVertex CreateVertex(OutputVertex v)
{
	OutputVertex vertex;
	vertex.position = mul(_LocalToWorldMatrix, float4(v.position, 1.0f)).xyz;
	return vertex;
}

void AppendTriangleToBuffer(OutputVertex a, OutputVertex b, OutputVertex c)
{
	float3 normal = GetTriangleNormal(a.position, b.position, c.position); //normal needs to be recalculated.
	OutputTriangle tri;
	tri.normal = normal;
	tri.vertices[0] = a;
	tri.vertices[1] = b;
	tri.vertices[2] = c;

	_outputTriangles.Append(tri);

}

void GetCenterAndBasis(OutputVertex a, OutputVertex b, OutputVertex c, out float3 position, out float3 normal, out float3x3 tangentSpace)
{
	//float3 posA = mul(_LocalToWorldMatrix, float4(a.position, 1.0f)).xyz;
	//float3 posB = mul(_LocalToWorldMatrix, float4(b.position, 1.0f)).xyz;
	//float3 posC = mul(_LocalToWorldMatrix, float4(c.position, 1.0f)).xyz;

	//Center
	position = GetTriangleCenter(a.position, b.position, c.position);

	//To tangent space.
	GetTriangleNormalAndTSMatrix(a.position, b.position, c.position, normal, tangentSpace);
}

OutputVertex GeneratePoint(float3 anchor, float3 normal, float2 dimensions, float3x3 tangentSpace, float2 uv)
{
	float3 offsetTS = float3((uv.x - 0.5f) * dimensions.x, 0, uv.y * dimensions.y);
	
	//convert to object space.
	float3 offsetOS = mul(tangentSpace, offsetTS);
	
	OutputVertex output = (OutputVertex)0;
	output.position = anchor + offsetOS;
	output.normal = normal;
	output.uv = uv;
	return output;
}
//Now write the main function. ID is the thread currently running.
[numthreads(128, 1, 1)]
void Main(uint3 id : SV_DispatchThreadID)
{
	//Ensure it isn't using more compute than triangles.
	if ((int)id.x >= _NumOfTriangles)
		return;

	//Now take the triangle, add in a middle point, extrodue it by the height, and save it as a buffer.

	int indexOfTriangle = id.x * 3; //This tells us where we are on this thread to compute the triangle. This is like a pixel shader but manually...
	
	OutputVertex vertices[6];
	vertices[0] = CreateVertex(_sourceVertices[_sourceTriangles[indexOfTriangle]]);
	vertices[1] = CreateVertex(_sourceVertices[_sourceTriangles[indexOfTriangle + 1]]);
	vertices[2] = CreateVertex(_sourceVertices[_sourceTriangles[indexOfTriangle + 2]]);
	float3 position, normal;
	float3x3 tangentSpace;
	GetCenterAndBasis(
		vertices[0],
		vertices[1],
		vertices[2],
		position,
		normal,
		tangentSpace
	);

	float2 dimensions = float2(_Width, _Height);
	
	float3x3 twist = AngleAxis3x3(rand(position, 2) * UNITY_PI * 2, float3(0, 0, 1));
	
	float3x3 twistSpace = mul(tangentSpace, twist);
	//creating shape in tangent space.
	vertices[0] = GeneratePoint(position, normal, dimensions, twistSpace, float2(0,0));
	vertices[1] = GeneratePoint(position, normal, dimensions, twistSpace, float2(0, 1));
	vertices[2] = GeneratePoint(position, normal, dimensions, twistSpace, float2(1, 1));
	
	//Next triangle
	vertices[3] = GeneratePoint(position, normal, dimensions, twistSpace, float2(1, 1));
	vertices[4] = GeneratePoint(position, normal, dimensions, twistSpace, float2(1, 0));
	vertices[5] = GeneratePoint(position, normal, dimensions, twistSpace, float2(0, 0));

	//Now we need to append the triangle to the buffer.
	OutputTriangle Triangles = (OutputTriangle)0;
	Triangles.vertices[0] = vertices[0];
	Triangles.vertices[1] = vertices[1];
	Triangles.vertices[2] = vertices[2];
	
	Triangles.vertices[3] = vertices[3];
	Triangles.vertices[4] = vertices[4];
	Triangles.vertices[5] = vertices[5];
	Triangles.normal = normal;
	_outputTriangles.Append(Triangles);

	//Now add to indirect args.
	InterlockedAdd(_IndirectArgsBuffer[0].numVerticesPerInstance, 6);
}